{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About the AWS Deploy Tool for .NET AWS Deploy Tool for .NET is an interactive tool for the .NET CLI and the AWS Toolkit for Visual Studio that helps deploy .NET applications with minimum AWS knowledge, and with the fewest clicks or commands. Key capabilities AWS Deploy Tool has the following capabilities: Compute recommendations for your application \u2013 Get recommendations about the type of compute best suited for your application based on the application type. Dockerfile generation - The tool will generate a Dockerfile if needed, otherwise an existing Dockerfile will be used. Auto packaging and deployment \u2013 The tool builds the deployment artifacts, generates a deployment CDK project, provisions the infrastructure, and deploys your application to the chosen AWS compute. Repeatable and shareable deployments \u2013 You can generate and modify AWS Cloud Development Kit (CDK) deployment projects to fit your specific use case. You can also version control your projects and share them with your team for repeatable deployments. Help with learning AWS CDK for .NET! - Gradually learn the underlying AWS tools that AWS Deploy Tool for .NET is built on, such as the AWS CDK. Availability ... in .NET CLI AWS Deploy Tool for .NET is available for download as a NuGet package. See How to install section. ... in AWS Toolkit for Visual Studio The AWS Toolkit for Visual Studio exposes the same deployment functionality via the Publish to AWS feature. For information about toolkit versions and using the feature, see Publish to AWS in the AWS Toolkit for Visual Studio User Guide . Additional Resources The aws-dotnet-deploy GitHub repo. Blog Post: Reimagining the AWS .NET deployment experience . Blog Post: Update on our new AWS .NET Deployment Experience . Blog Post: Deployment Projects with the new AWS .NET Deployment Experience . Video: Re:Invent 2021: \u201cWhat\u2019s new with .NET development and deployment on AWS\u201d","title":"About the AWS Deploy Tool for .NET"},{"location":"#about-the-aws-deploy-tool-for-net","text":"AWS Deploy Tool for .NET is an interactive tool for the .NET CLI and the AWS Toolkit for Visual Studio that helps deploy .NET applications with minimum AWS knowledge, and with the fewest clicks or commands.","title":"About the AWS Deploy Tool for .NET"},{"location":"#key-capabilities","text":"AWS Deploy Tool has the following capabilities: Compute recommendations for your application \u2013 Get recommendations about the type of compute best suited for your application based on the application type. Dockerfile generation - The tool will generate a Dockerfile if needed, otherwise an existing Dockerfile will be used. Auto packaging and deployment \u2013 The tool builds the deployment artifacts, generates a deployment CDK project, provisions the infrastructure, and deploys your application to the chosen AWS compute. Repeatable and shareable deployments \u2013 You can generate and modify AWS Cloud Development Kit (CDK) deployment projects to fit your specific use case. You can also version control your projects and share them with your team for repeatable deployments. Help with learning AWS CDK for .NET! - Gradually learn the underlying AWS tools that AWS Deploy Tool for .NET is built on, such as the AWS CDK.","title":"Key capabilities"},{"location":"#availability","text":"","title":"Availability"},{"location":"#in-net-cli","text":"AWS Deploy Tool for .NET is available for download as a NuGet package. See How to install section.","title":"... in .NET CLI"},{"location":"#in-aws-toolkit-for-visual-studio","text":"The AWS Toolkit for Visual Studio exposes the same deployment functionality via the Publish to AWS feature. For information about toolkit versions and using the feature, see Publish to AWS in the AWS Toolkit for Visual Studio User Guide .","title":"... in AWS Toolkit for Visual Studio"},{"location":"#additional-resources","text":"The aws-dotnet-deploy GitHub repo. Blog Post: Reimagining the AWS .NET deployment experience . Blog Post: Update on our new AWS .NET Deployment Experience . Blog Post: Deployment Projects with the new AWS .NET Deployment Experience . Video: Re:Invent 2021: \u201cWhat\u2019s new with .NET development and deployment on AWS\u201d","title":"Additional Resources"},{"location":"contributing/","text":"The AWS Deploy Tool for .NET is an open source project hosted on GitHub and we openly welcome community contributions. Click here to submit a pull request. Using the Deployment Tool from Source Ensure that all the pre-requisties (including Docker) are installed and your default AWS profile has admin access Clone the repository using git clone https://github.com/aws/aws-dotnet-deploy.git Open AWS.Deploy.sln in Visual Studio. Ensure that src/AWS.Deloy.CLI is set as the start up project. Go to AWS.Deploy.CLI debug properties by clicking the following drop down Add a new launch profile called AWS.Deploy.CLI In the Command line arguments text box add the following (leave other text boxes blank): deploy \u2014project-path path/to/aws-dotnet-deploy/testapps/WebAppWithDockerFile The above command assumes you have a [default] profile configured in your AWS credentials file. If you want to use a different profile, use the --profile switch. You can also specify a different region via the --region switch. Select the AWS.Deploy.CLI launch profile and run the tool Follow the prompts on the screen and perform a deployment using any compatible recommendation. A successful deployment indicates that your environment is set up correctly and you can proceed to debugging the source code. Repository Overview The .NET deployment tool comprises of various top level components. AWS.Deploy.CLI This component controls the UI elements for the .NET deployment tool and serves as the first entry point when running the tool. This is the layer that end users directly interact with and it uses the System.CommandLine package for the CLI UX. Key Components Program.cs - Serves as the entry point to the CLI application. CustomServiceCollectionExtension - This serves as the dependency injection container and registers all the dependencies required by the deployment tool. CommandFactory - This instantiates and executes the top-level dotnet aws command and other sub-commands like deploy , list-deployments and delete-deployment . It also holds all the CLI switches that are applicable to the any command. All new commands/switches will be declared and instantiated via this class. CommandHandlerInput - This contains the POCO objects that hold the values for all CLI switches of the associated command. These objects are provided as input while creating the command handlers. See here for an example. TypeHintCommandFactory - Some of the option settings require special logic on how to prompt the user for a value and how to parse the user input. This class stores the mapping between the option settings and their corresponding typehints. TypeHints can be found here . TypeHintResponses can be found here ConsoleUtilities - Contains utility methods to drive the CLI UX CommandLineWrapper - Contains utility methods to invoke command line processes like docker build or cdk deploy Exceptions - Declares all exceptions that are thrown by the AWS.Deploy.CLI component AWS.Deploy.CLI.UnitTests - Contains unit tests for this component AWS.Deploy.Recipes This component contains the recipes that serve as the backbone of each deployment recommendation. It also contains the CDK templates that is used to deploy the customer\u2019s .NET application as a CloudFormation stack Key Components RecipeDefinitions - It contains the deployment recipes that target different AWS services. Each recipe file contains a list of option settings which is a collection of AWS resources that users can customize as per their needs. See here to learn more about the recipe file schema. See here to look at the support matrix between recipes and different .NET application types. DeploymentBundleDefinitions - It contains the common option settings that users can customize for container based and non-container based recipes. All recipes have a DeploymentBundle property that specifies how to package the user\u2019s .NET project for deployment. Container - Indicates that Docker is used to build the Docker image and pushed to Amazon Elastic Container Registry. DotnetPublishZipFile - Indicates that the dotnet publish is used to prepare the user\u2019s .NET project for deployment. CdkTemplates - It contains the CDK templates for recipe files found here . All recipes with the DeploymentType set to \u201cCdkProject\u201d have their own specific CDK template identified by the CdkProjectTemplate property. AWS.Deploy.CDK.Common This component contains the common utility classes and methods that are used by the CDK templates found here . Note - The AWS.Deploy.CDK.Common.csproj is never referenced directly because it contains the Amazon.CDK.Lib package which is close to 70 MB is size. Instead, if we need functionality from this project then we directly link the appropriate .cs files. See here for an example. AWS.Deploy.Common This component contains POCO objects and common logic that is used by other components in the deployment tool Note - This project does not reference any other project except for ../src/AWS.Deploy.Constants/AWS.Deploy.Constants.projitems Key Components ProjectDefinitionParser - This class contains the logic to validate whether a .NET project exists at the path specified via dotnet aws deploy \u2014project-path <PROJECT-PATH> . It also parses the user\u2019s csproj/fsproj file and returns a ProjectDefinition RecipeDefinition - This is a POCO class that serves as the deserialized model for all recipe files found here Recommendation - This is a POCO class that stores different metadata such as the RecipeDefinition and ProjectDefinition . There is 1:1 mapping between each recipe file and a recommendation object. Each recommendation object has a computed priority which determines its precedence. DeploymentBundleDefinition - This is a POCO class that serves as the deserialized model for all DeploymentBundleDefinitions OptionSettingItem - This is a POCO class that serves as the deserialized model for option settings found inside deployment recipes . These settings can be tweaked by the user to customize their deployment. This is defined as a partial class and the rest of its functionality is specified inside OptionSettingItem.ValueOverride ValidatorFactory - The deployment tool performs input validation to guard against invalid input. These validators are specified inside the recipe files and can either be a recipe-level validator or an optionSetting-level validator. The ValidatorFactory is responsible for invoking the correct validator depending on the option setting being configured. Exceptions - Declares all exceptions that are thrown by the AWS.Deploy.Common component. It also specifies the error codes that are associated with all exceptions thrown by the deployment tool ( Note - The error codes are only bundled with exceptions that implement DeployToolException abstract class. These exceptions are caused by a user error and can be remedied by the user based on the error message thrown.) AWS.Deploy.CLI.Common.UnitTests - Contains unit tests for this component. AWS.Deploy.DockerEngine This component contains all the logic for dealing with Docker. Some of its responsibilities are outlined below: Generating a Dockerfile if the user\u2019s project does not contain one. Note - a Dockerfile is only generated when deploying via a container-based recommendation such as ASP.NETAppAppRunner.recipe or ASP.NETAppECSFargate.recipe Determining the Docker execution directory . It serves as the working directory for the docker build command and all relative paths in the Dockerfile are resolved from this directory. AWS.Deploy.Orchestration This component serves as the main workhorse for the deployment tooling and it contains the most number of logical pieces. Key Components Orchestrator - It holds various dependencies required by the deployment tool and its design is aligned with the composition over inheritance philosophy. OrchestratorSession - This is a POCO class that holds the user\u2019s AWS credentials, the deployment region, AWS account ID and metadata about the user\u2019s .NET project. DeploymentCommandFactory - The deployment tool supports different deployment types (CDK based, existing Beanstalk environment, Pushing to ECR). Each type has its own deployment command and this mapping is stored inside the DeploymentCommandFactory. IOrchestratorInteractiveService - This interface defines the logging service for the deployment tool. SystemCapabilityEvaluator - Verifies that pre-requisties such as Docker and Node.js (required for CDK) are installed on the user\u2019s system RecommendationEngine - This is responsible for parsing the recipe files into a Recommendation object. It also computes the priority by running the recommendation rules against the customer\u2019s .NET project RecipeHandler - It contains methods to parse recipe files, locate custom (user defined) recipes and run recipe level validators OptionSettingHandler - It contains methods to interact with option settings. Some of its functionality includes modifying the value, retrieving the current value and running option setting validators. DeploymentSettingsHandler - Users can create their own deployment settings file that specifies a list of option settings and their values (See here for an example). The user can invoke dotnet aws deploy --apply <SETTINGS-FILE-PATH> --silent which applies the option settings values, runs all validators and kicks off a deployment without any user prompts. DeploymentSettingsHandler is responsible for parsing the settings file and applying the option setting values. AWSResourceQueryer - Contains methods to query resources from different AWS services. DeploymentBundleHandler - All recipes have a DeploymentBundle property that specifies how to package the user\u2019s .NET project for deployment. DeploymentBundleHandler is reponsible for creating the appropriate deployment bundle DeployedApplicationQueryer - It contains the functionality to retrieve the list of previously deployed applications and can also determine if an existing cloud application can be redeployed using the current set of recommendations. CdkProjectHandler - Contains all the logic to interact with CDK. CdkAppSettingsSerializer - It writes all the deployment settings into the appsettings.json file. This file is then deserialized into IRecipeProps and passed to the CDK templates. Exceptions.cs - Declares all exceptions that are thrown by the AWS.Deploy.Orchestration component AWS.Deploy.Orchestration.UnitTests - Contains unit tests for this component AWS.Deploy.Constants This is a shared project and contains various constants used throughout the codebase AWS.Deploy.CLI.IntegrationTests This contains the integration test suite Server Mode To support IDEs using the AWS .NET Deploy tool the CLI can be launched in server mode. This will run the CLI as a server that exposes an API IDEs will be able to interact with to perform deployment activities. When the server mode is started the deploy tool will act as an ASP.NET Core application. Server mode will keep all of the deployment logic and rules inside the deploy tool CLI. IDEs are treated as frontends rendering the information that comes from the deploy tool and passing any of the information the user has specified into the deploy tool to validate and persist. Debugging the .NET Deployment Tool via Server Mode Install the AWS Toolkit for Visual Studio Open the following file in a text editor - %localappdata%\\AWSToolkit\\PublishSettings.json Under the DeployServer parent, add a new property AlternateCliPath that points to the AWS.Deploy.CLI executable. This instruct the Toolkit to launch the deploy tool from a custom location. Example { \"DeployServer\":{ \"AlternateCliPath\":\"C:\\\\code\\\\aws-dotnet-deploy\\\\src\\\\AWS.Deploy.CLI\\\\bin\\\\Release\\\\net6.0\\\\AWS.Deploy.CLI.exe\", \"PortRange\":{ \"Start\":10000, \"End\":10100 } } } Follow these steps to attach a debugger: Launch a new Visual Studio window, and begin deploying a test project to AWS. In another Visual Studio window with Deploy Tool solution open, select Debug > Attach to Process then choose the AWS.Deploy.CLI.exe process that was started by the previous step. Key Components AWS.Deploy.CLI.ServerMode - It contains various Swagger based API controllers and POCO models that govern the REST API behaviour AWS.Deploy.ServerMode.ClientGenerator - This ingests the API specification file ( swagger.json ) to generate the REST API client. AWS.Deploy.ServerMode.Client - This is the actual REST API client used by the frontend (VS Toolkit) to interact with the deployment tool CLI. Build and Test Documentation Install Material for MkDocs Material for MkDocs is a theme for MkDocs, a static site generator geared towards (technical) project documentation. If you're familiar with Python, you can install Material for MkDocs with pip, the Python package manager. pip install mkdocs-material For, other installation options see here Deploying to a Local Server MkDocs comes with a built-in dev-server that lets you preview your documentation as you work on it. From the root of the project repository, run the following command: mkdocs serve Paste the link to the local server on a web browser to look at the documentation. The dev-server also supports auto-reloading, and will rebuild your documentation whenever anything in the configuration file, documentation directory, or theme directory changes.","title":"Contributing"},{"location":"contributing/#using-the-deployment-tool-from-source","text":"Ensure that all the pre-requisties (including Docker) are installed and your default AWS profile has admin access Clone the repository using git clone https://github.com/aws/aws-dotnet-deploy.git Open AWS.Deploy.sln in Visual Studio. Ensure that src/AWS.Deloy.CLI is set as the start up project. Go to AWS.Deploy.CLI debug properties by clicking the following drop down Add a new launch profile called AWS.Deploy.CLI In the Command line arguments text box add the following (leave other text boxes blank): deploy \u2014project-path path/to/aws-dotnet-deploy/testapps/WebAppWithDockerFile The above command assumes you have a [default] profile configured in your AWS credentials file. If you want to use a different profile, use the --profile switch. You can also specify a different region via the --region switch. Select the AWS.Deploy.CLI launch profile and run the tool Follow the prompts on the screen and perform a deployment using any compatible recommendation. A successful deployment indicates that your environment is set up correctly and you can proceed to debugging the source code.","title":"Using the Deployment Tool from Source"},{"location":"contributing/#repository-overview","text":"The .NET deployment tool comprises of various top level components.","title":"Repository Overview"},{"location":"contributing/#awsdeploycli","text":"This component controls the UI elements for the .NET deployment tool and serves as the first entry point when running the tool. This is the layer that end users directly interact with and it uses the System.CommandLine package for the CLI UX. Key Components Program.cs - Serves as the entry point to the CLI application. CustomServiceCollectionExtension - This serves as the dependency injection container and registers all the dependencies required by the deployment tool. CommandFactory - This instantiates and executes the top-level dotnet aws command and other sub-commands like deploy , list-deployments and delete-deployment . It also holds all the CLI switches that are applicable to the any command. All new commands/switches will be declared and instantiated via this class. CommandHandlerInput - This contains the POCO objects that hold the values for all CLI switches of the associated command. These objects are provided as input while creating the command handlers. See here for an example. TypeHintCommandFactory - Some of the option settings require special logic on how to prompt the user for a value and how to parse the user input. This class stores the mapping between the option settings and their corresponding typehints. TypeHints can be found here . TypeHintResponses can be found here ConsoleUtilities - Contains utility methods to drive the CLI UX CommandLineWrapper - Contains utility methods to invoke command line processes like docker build or cdk deploy Exceptions - Declares all exceptions that are thrown by the AWS.Deploy.CLI component AWS.Deploy.CLI.UnitTests - Contains unit tests for this component","title":"AWS.Deploy.CLI"},{"location":"contributing/#awsdeployrecipes","text":"This component contains the recipes that serve as the backbone of each deployment recommendation. It also contains the CDK templates that is used to deploy the customer\u2019s .NET application as a CloudFormation stack Key Components RecipeDefinitions - It contains the deployment recipes that target different AWS services. Each recipe file contains a list of option settings which is a collection of AWS resources that users can customize as per their needs. See here to learn more about the recipe file schema. See here to look at the support matrix between recipes and different .NET application types. DeploymentBundleDefinitions - It contains the common option settings that users can customize for container based and non-container based recipes. All recipes have a DeploymentBundle property that specifies how to package the user\u2019s .NET project for deployment. Container - Indicates that Docker is used to build the Docker image and pushed to Amazon Elastic Container Registry. DotnetPublishZipFile - Indicates that the dotnet publish is used to prepare the user\u2019s .NET project for deployment. CdkTemplates - It contains the CDK templates for recipe files found here . All recipes with the DeploymentType set to \u201cCdkProject\u201d have their own specific CDK template identified by the CdkProjectTemplate property.","title":"AWS.Deploy.Recipes"},{"location":"contributing/#awsdeploycdkcommon","text":"This component contains the common utility classes and methods that are used by the CDK templates found here . Note - The AWS.Deploy.CDK.Common.csproj is never referenced directly because it contains the Amazon.CDK.Lib package which is close to 70 MB is size. Instead, if we need functionality from this project then we directly link the appropriate .cs files. See here for an example.","title":"AWS.Deploy.CDK.Common"},{"location":"contributing/#awsdeploycommon","text":"This component contains POCO objects and common logic that is used by other components in the deployment tool Note - This project does not reference any other project except for ../src/AWS.Deploy.Constants/AWS.Deploy.Constants.projitems Key Components ProjectDefinitionParser - This class contains the logic to validate whether a .NET project exists at the path specified via dotnet aws deploy \u2014project-path <PROJECT-PATH> . It also parses the user\u2019s csproj/fsproj file and returns a ProjectDefinition RecipeDefinition - This is a POCO class that serves as the deserialized model for all recipe files found here Recommendation - This is a POCO class that stores different metadata such as the RecipeDefinition and ProjectDefinition . There is 1:1 mapping between each recipe file and a recommendation object. Each recommendation object has a computed priority which determines its precedence. DeploymentBundleDefinition - This is a POCO class that serves as the deserialized model for all DeploymentBundleDefinitions OptionSettingItem - This is a POCO class that serves as the deserialized model for option settings found inside deployment recipes . These settings can be tweaked by the user to customize their deployment. This is defined as a partial class and the rest of its functionality is specified inside OptionSettingItem.ValueOverride ValidatorFactory - The deployment tool performs input validation to guard against invalid input. These validators are specified inside the recipe files and can either be a recipe-level validator or an optionSetting-level validator. The ValidatorFactory is responsible for invoking the correct validator depending on the option setting being configured. Exceptions - Declares all exceptions that are thrown by the AWS.Deploy.Common component. It also specifies the error codes that are associated with all exceptions thrown by the deployment tool ( Note - The error codes are only bundled with exceptions that implement DeployToolException abstract class. These exceptions are caused by a user error and can be remedied by the user based on the error message thrown.) AWS.Deploy.CLI.Common.UnitTests - Contains unit tests for this component.","title":"AWS.Deploy.Common"},{"location":"contributing/#awsdeploydockerengine","text":"This component contains all the logic for dealing with Docker. Some of its responsibilities are outlined below: Generating a Dockerfile if the user\u2019s project does not contain one. Note - a Dockerfile is only generated when deploying via a container-based recommendation such as ASP.NETAppAppRunner.recipe or ASP.NETAppECSFargate.recipe Determining the Docker execution directory . It serves as the working directory for the docker build command and all relative paths in the Dockerfile are resolved from this directory.","title":"AWS.Deploy.DockerEngine"},{"location":"contributing/#awsdeployorchestration","text":"This component serves as the main workhorse for the deployment tooling and it contains the most number of logical pieces. Key Components Orchestrator - It holds various dependencies required by the deployment tool and its design is aligned with the composition over inheritance philosophy. OrchestratorSession - This is a POCO class that holds the user\u2019s AWS credentials, the deployment region, AWS account ID and metadata about the user\u2019s .NET project. DeploymentCommandFactory - The deployment tool supports different deployment types (CDK based, existing Beanstalk environment, Pushing to ECR). Each type has its own deployment command and this mapping is stored inside the DeploymentCommandFactory. IOrchestratorInteractiveService - This interface defines the logging service for the deployment tool. SystemCapabilityEvaluator - Verifies that pre-requisties such as Docker and Node.js (required for CDK) are installed on the user\u2019s system RecommendationEngine - This is responsible for parsing the recipe files into a Recommendation object. It also computes the priority by running the recommendation rules against the customer\u2019s .NET project RecipeHandler - It contains methods to parse recipe files, locate custom (user defined) recipes and run recipe level validators OptionSettingHandler - It contains methods to interact with option settings. Some of its functionality includes modifying the value, retrieving the current value and running option setting validators. DeploymentSettingsHandler - Users can create their own deployment settings file that specifies a list of option settings and their values (See here for an example). The user can invoke dotnet aws deploy --apply <SETTINGS-FILE-PATH> --silent which applies the option settings values, runs all validators and kicks off a deployment without any user prompts. DeploymentSettingsHandler is responsible for parsing the settings file and applying the option setting values. AWSResourceQueryer - Contains methods to query resources from different AWS services. DeploymentBundleHandler - All recipes have a DeploymentBundle property that specifies how to package the user\u2019s .NET project for deployment. DeploymentBundleHandler is reponsible for creating the appropriate deployment bundle DeployedApplicationQueryer - It contains the functionality to retrieve the list of previously deployed applications and can also determine if an existing cloud application can be redeployed using the current set of recommendations. CdkProjectHandler - Contains all the logic to interact with CDK. CdkAppSettingsSerializer - It writes all the deployment settings into the appsettings.json file. This file is then deserialized into IRecipeProps and passed to the CDK templates. Exceptions.cs - Declares all exceptions that are thrown by the AWS.Deploy.Orchestration component AWS.Deploy.Orchestration.UnitTests - Contains unit tests for this component","title":"AWS.Deploy.Orchestration"},{"location":"contributing/#awsdeployconstants","text":"This is a shared project and contains various constants used throughout the codebase","title":"AWS.Deploy.Constants"},{"location":"contributing/#awsdeploycliintegrationtests","text":"This contains the integration test suite","title":"AWS.Deploy.CLI.IntegrationTests"},{"location":"contributing/#server-mode","text":"To support IDEs using the AWS .NET Deploy tool the CLI can be launched in server mode. This will run the CLI as a server that exposes an API IDEs will be able to interact with to perform deployment activities. When the server mode is started the deploy tool will act as an ASP.NET Core application. Server mode will keep all of the deployment logic and rules inside the deploy tool CLI. IDEs are treated as frontends rendering the information that comes from the deploy tool and passing any of the information the user has specified into the deploy tool to validate and persist. Debugging the .NET Deployment Tool via Server Mode Install the AWS Toolkit for Visual Studio Open the following file in a text editor - %localappdata%\\AWSToolkit\\PublishSettings.json Under the DeployServer parent, add a new property AlternateCliPath that points to the AWS.Deploy.CLI executable. This instruct the Toolkit to launch the deploy tool from a custom location. Example { \"DeployServer\":{ \"AlternateCliPath\":\"C:\\\\code\\\\aws-dotnet-deploy\\\\src\\\\AWS.Deploy.CLI\\\\bin\\\\Release\\\\net6.0\\\\AWS.Deploy.CLI.exe\", \"PortRange\":{ \"Start\":10000, \"End\":10100 } } } Follow these steps to attach a debugger: Launch a new Visual Studio window, and begin deploying a test project to AWS. In another Visual Studio window with Deploy Tool solution open, select Debug > Attach to Process then choose the AWS.Deploy.CLI.exe process that was started by the previous step. Key Components AWS.Deploy.CLI.ServerMode - It contains various Swagger based API controllers and POCO models that govern the REST API behaviour AWS.Deploy.ServerMode.ClientGenerator - This ingests the API specification file ( swagger.json ) to generate the REST API client. AWS.Deploy.ServerMode.Client - This is the actual REST API client used by the frontend (VS Toolkit) to interact with the deployment tool CLI.","title":"Server Mode"},{"location":"contributing/#build-and-test-documentation","text":"","title":"Build and Test Documentation"},{"location":"contributing/#install-material-for-mkdocs","text":"Material for MkDocs is a theme for MkDocs, a static site generator geared towards (technical) project documentation. If you're familiar with Python, you can install Material for MkDocs with pip, the Python package manager. pip install mkdocs-material For, other installation options see here","title":"Install Material for MkDocs"},{"location":"contributing/#deploying-to-a-local-server","text":"MkDocs comes with a built-in dev-server that lets you preview your documentation as you work on it. From the root of the project repository, run the following command: mkdocs serve Paste the link to the local server on a web browser to look at the documentation. The dev-server also supports auto-reloading, and will rebuild your documentation whenever anything in the configuration file, documentation directory, or theme directory changes.","title":"Deploying to a Local Server"},{"location":"faq/","text":"Frequently Asked Questions FAQ: I have an existing .NET application. Can I use the AWS Deploy Tool to deploy it to AWS? Yes, the AWS Deploy Tool can be used to deploy any cloud-native .NET applications to AWS. A cloud-native .NET application is written in .NET with intent to deploy to Linux, not tied to any Windows specific technology such as Windows registry, IIS or MSMQ, and can be deployed on virtualized compute. It cannot be used to deploy .NET Framework, Desktop, Xamarin, or other applications that do not fit the \u201ccloud-native\u201d criteria. FAQ: How does the AWS Deploy Tool decide what service to choose for deployment? It examines the .NET project file and project dependencies, and inspects the code for attribution and Dockerfile presence to figure out the application type and the service best suited to run the application. FAQ: How will my application be packaged and deployed? Once the AWS compute service is chosen, the deployment tool will package your application binary artifacts in the appropriate format for that service (for example zip file for AWS Elastic Beanstalk) and deploy it using the AWS Cloud Development Kit (CDK) . Once the application is deployed, it will return an endpoint for the application (for example URL for API backend, or SQS queue for messaging app). FAQ: How does the AWS Deploy Tool create infrastructure? It generates a .NET CDK project for the suggested service and uses the .NET CDK binding to build constructs. If you are not ready to learn CDK, it will auto-generate the default .NET CDK project behind the scenes. You can also change or extend the CDK project\u2019s behavior to match your exact needs and then execute the deployment. FAQ: Can I re-deploy my application to a different stack? Yes. The AWS Deploy Tool saves your deployment settings, including the environment name (such as the name of the AWS CloudFormation stack) your application was deployed to. When you re-run dotnet aws deploy command, it will detect these previously saved settings, and ask if you want to re-deploy to the same or a different environment. If you choose the latter, it will create a new deployment stack. FAQ: Can I choose a different AWS service to deploy my application? The AWS Deploy Tool will show you all compute service options available to deploy your application, and will recommend a default with information about why it was chosen. The other compute service options will be shown with an explanation of their differences. If the selected compute option does not match your need, you can select a different compute service. FAQ: I have an application that has dependency on Windows technology, can I use the AWS Deploy Tool to deploy it to AWS? ASP.NET Core applications can be deployed to AWS Elastic Beanstalk picking the \"ASP.NET Core App to AWS Elastic Beanstalk on Windows\" recommendation. The deployment experience is very similar the \"ASP.NET Core App to AWS Elastic Beanstalk on Linux\" recommendation with additional settings for configuring the Internet Information Services (IIS) resource path and web site. FAQ: Can I deploy my application from Visual Studio? Yes, you can deploy your application using the \"Publish to AWS\" feature in the AWS Toolkit for Visual Studio. This feature exposes the same functionality as the AWS Deploy Tool for .NET CLI. To learn more, go to Publish to AWS in the AWS Toolkit for Visual Studio User Guide. FAQ: Can I invoke AWS Deploy Tool from my CI/CD pipeline? Yes, you can. To learn more, go to Integrating with CI/CD","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#faq-i-have-an-existing-net-application-can-i-use-the-aws-deploy-tool-to-deploy-it-to-aws","text":"Yes, the AWS Deploy Tool can be used to deploy any cloud-native .NET applications to AWS. A cloud-native .NET application is written in .NET with intent to deploy to Linux, not tied to any Windows specific technology such as Windows registry, IIS or MSMQ, and can be deployed on virtualized compute. It cannot be used to deploy .NET Framework, Desktop, Xamarin, or other applications that do not fit the \u201ccloud-native\u201d criteria.","title":"FAQ: I have an existing .NET application. Can I use the AWS Deploy Tool to deploy it to AWS?"},{"location":"faq/#faq-how-does-the-aws-deploy-tool-decide-what-service-to-choose-for-deployment","text":"It examines the .NET project file and project dependencies, and inspects the code for attribution and Dockerfile presence to figure out the application type and the service best suited to run the application.","title":"FAQ: How does the AWS Deploy Tool decide what service to choose for deployment?"},{"location":"faq/#faq-how-will-my-application-be-packaged-and-deployed","text":"Once the AWS compute service is chosen, the deployment tool will package your application binary artifacts in the appropriate format for that service (for example zip file for AWS Elastic Beanstalk) and deploy it using the AWS Cloud Development Kit (CDK) . Once the application is deployed, it will return an endpoint for the application (for example URL for API backend, or SQS queue for messaging app).","title":"FAQ: How will my application be packaged and deployed?"},{"location":"faq/#faq-how-does-the-aws-deploy-tool-create-infrastructure","text":"It generates a .NET CDK project for the suggested service and uses the .NET CDK binding to build constructs. If you are not ready to learn CDK, it will auto-generate the default .NET CDK project behind the scenes. You can also change or extend the CDK project\u2019s behavior to match your exact needs and then execute the deployment.","title":"FAQ: How does the AWS Deploy Tool create infrastructure?"},{"location":"faq/#faq-can-i-re-deploy-my-application-to-a-different-stack","text":"Yes. The AWS Deploy Tool saves your deployment settings, including the environment name (such as the name of the AWS CloudFormation stack) your application was deployed to. When you re-run dotnet aws deploy command, it will detect these previously saved settings, and ask if you want to re-deploy to the same or a different environment. If you choose the latter, it will create a new deployment stack.","title":"FAQ: Can I re-deploy my application to a different stack?"},{"location":"faq/#faq-can-i-choose-a-different-aws-service-to-deploy-my-application","text":"The AWS Deploy Tool will show you all compute service options available to deploy your application, and will recommend a default with information about why it was chosen. The other compute service options will be shown with an explanation of their differences. If the selected compute option does not match your need, you can select a different compute service.","title":"FAQ: Can I choose a different AWS service to deploy my application?"},{"location":"faq/#faq-i-have-an-application-that-has-dependency-on-windows-technology-can-i-use-the-aws-deploy-tool-to-deploy-it-to-aws","text":"ASP.NET Core applications can be deployed to AWS Elastic Beanstalk picking the \"ASP.NET Core App to AWS Elastic Beanstalk on Windows\" recommendation. The deployment experience is very similar the \"ASP.NET Core App to AWS Elastic Beanstalk on Linux\" recommendation with additional settings for configuring the Internet Information Services (IIS) resource path and web site.","title":"FAQ: I have an application that has dependency on Windows technology, can I use the AWS Deploy Tool to deploy it to AWS?"},{"location":"faq/#faq-can-i-deploy-my-application-from-visual-studio","text":"Yes, you can deploy your application using the \"Publish to AWS\" feature in the AWS Toolkit for Visual Studio. This feature exposes the same functionality as the AWS Deploy Tool for .NET CLI. To learn more, go to Publish to AWS in the AWS Toolkit for Visual Studio User Guide.","title":"FAQ: Can I deploy my application from Visual Studio?"},{"location":"faq/#faq-can-i-invoke-aws-deploy-tool-from-my-cicd-pipeline","text":"Yes, you can. To learn more, go to Integrating with CI/CD","title":"FAQ: Can I invoke AWS Deploy Tool from my CI/CD pipeline?"},{"location":"docs/support/","text":"Support Matrix The table below provides a matrix of supported .NET application types and AWS Computes. .NET Console App ASP.NET Core Blazor WebAssembly Amazon Elastic Container Service (ECS) service (Linux) Amazon Elastic Container Service (ECS) task (Linux) AWS App Runner (Linux) AWS Elastic Beanstalk (Linux and Windows) Amazon S3 & Amazon CloudFront Amazon Elastic Container Service (Amazon ECS) using AWS Fargate Supports deployments of .NET applications as a service (e.g. web application or a background processor) or as a scheduled task (e.g. end-of-day process) to Amazon Elastic Container Service (Amazon ECS) with compute power managed by the AWS Fargate serverless compute engine. Recommended if you want to deploy a service or a scheduled task as a container image on Linux. Note: This compute requires a Dockerfile. IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used. Amazon Elastic Container Service (Amazon ECS) is a fully managed container orchestration service that helps you easily deploy, manage, and scale containerized applications. AWS Fargate is a serverless, pay-as-you-go compute engine that lets you focus on building applications without managing servers. AWS App Runner Supports deployments of containerized ASP.NET Core applications to AWS App Runner. Recommended if you want to deploy your application as a container image on a fully managed environment. Note: This compute requires a Dockerfile. IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used. AWS App Runner is a fully managed service that makes it easy for developers to quickly deploy containerized web applications and APIs, at scale and with no prior infrastructure experience required. With App Runner, rather than thinking about servers or scaling, you have more time to focus on your applications. AWS Elastic Beanstalk Supports deployments of ASP.NET Core applications to AWS Elastic Beanstalk on Linux and Windows. Recommended if you want to deploy your application directly to EC2 hosts. AWS Elastic Beanstalk is an easy-to-use service for deploying and scaling web applications and services. AWS Elastic Beanstalk automatically handles the deployment, from capacity provisioning, load balancing, auto-scaling to application health monitoring. Hosting Blazor WebAssembly applications using Amazon S3 and Amazon CloudFront Blazor WebAssembly applications can be deployed to an Amazon S3 bucket for web hosting. The Amazon S3 bucket will be created and configured automatically by the tool, which will then upload your Blazor application to the S3 bucket.","title":"Support Matrix"},{"location":"docs/support/#support-matrix","text":"The table below provides a matrix of supported .NET application types and AWS Computes. .NET Console App ASP.NET Core Blazor WebAssembly Amazon Elastic Container Service (ECS) service (Linux) Amazon Elastic Container Service (ECS) task (Linux) AWS App Runner (Linux) AWS Elastic Beanstalk (Linux and Windows) Amazon S3 & Amazon CloudFront","title":"Support Matrix"},{"location":"docs/support/#amazon-elastic-container-service-amazon-ecs-using-aws-fargate","text":"Supports deployments of .NET applications as a service (e.g. web application or a background processor) or as a scheduled task (e.g. end-of-day process) to Amazon Elastic Container Service (Amazon ECS) with compute power managed by the AWS Fargate serverless compute engine. Recommended if you want to deploy a service or a scheduled task as a container image on Linux. Note: This compute requires a Dockerfile. IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used. Amazon Elastic Container Service (Amazon ECS) is a fully managed container orchestration service that helps you easily deploy, manage, and scale containerized applications. AWS Fargate is a serverless, pay-as-you-go compute engine that lets you focus on building applications without managing servers.","title":"Amazon Elastic Container Service (Amazon ECS) using AWS Fargate"},{"location":"docs/support/#aws-app-runner","text":"Supports deployments of containerized ASP.NET Core applications to AWS App Runner. Recommended if you want to deploy your application as a container image on a fully managed environment. Note: This compute requires a Dockerfile. IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used. AWS App Runner is a fully managed service that makes it easy for developers to quickly deploy containerized web applications and APIs, at scale and with no prior infrastructure experience required. With App Runner, rather than thinking about servers or scaling, you have more time to focus on your applications.","title":"AWS App Runner"},{"location":"docs/support/#aws-elastic-beanstalk","text":"Supports deployments of ASP.NET Core applications to AWS Elastic Beanstalk on Linux and Windows. Recommended if you want to deploy your application directly to EC2 hosts. AWS Elastic Beanstalk is an easy-to-use service for deploying and scaling web applications and services. AWS Elastic Beanstalk automatically handles the deployment, from capacity provisioning, load balancing, auto-scaling to application health monitoring.","title":"AWS Elastic Beanstalk"},{"location":"docs/support/#hosting-blazor-webassembly-applications-using-amazon-s3-and-amazon-cloudfront","text":"Blazor WebAssembly applications can be deployed to an Amazon S3 bucket for web hosting. The Amazon S3 bucket will be created and configured automatically by the tool, which will then upload your Blazor application to the S3 bucket.","title":"Hosting Blazor WebAssembly applications using Amazon S3 and Amazon CloudFront"},{"location":"docs/cicd/cicd/","text":"Integrating with CI/CD You can use AWS Deploy Tool when developing your app using any Continuous Deployment system. Continuous Deployment systems let you automatically build, test and deploy your application each time you check in updates to your source code. Before you can use AWS Deploy Tool in your CD pipeline, you must have required pre-requisites installed and configured in the CD environment. Suppressing prompts with --silent To turn off the interactive features, use the -s (--silent) switch. This will ensure the tool never prompts for any questions that could block an automated process. dotnet aws deploy --silent Creating a deployment settings file You can persist the deployment configuration to a JSON file using the --save-settings <SETTINGS_FILE_PATH)> switch. This JSON file can be version controlled and plugged into your CI/CD system for future deployments. Note - The --save-settings switch will only persist settings that have been modified (which means they hold a non-default value). To persist all settings use the --save-all-settings switch. dotnet aws deploy --project-path <PROJECT_PATH> [--save-settings|--save-all-settings] <SETTINGS_FILE_PATH> Note - The SETTINGS_FILE_PATH can be an absolute path or relative to the PROJECT_PATH . Here's an example of a web application with the following directory structure: MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2523 WeatherForecast.cs \u2517 MyWebApplication.sln To perform a deployment and also persist the deployment configuration to a JSON file, use the following command: dotnet aws deploy --project-path MyWebApplication/MyWebApplication/MyWebApplication.csproj --save-settings deploymentsettings.json This will create a JSON file at MyWebApplication/MyWebApplication/deploymentsettings.json with the following structure: { \"AWSProfile\": <AWS_PROFILE>, \"AWSRegion\": <AWS_REGION>, \"ApplicationName\": <APPLICATION_NAME>, \"RecipeId\": <RECIPE_ID>, \"Settings\": <JSON_BLOB> } AWSProfile : The name of the AWS profile that was used during deployment. AWSRegion : The name of the AWS region where the deployed application is hosted. ApplicationName : The name that is used to identify your cloud application within AWS. If the application is deployed via AWS CDK, then this name points to the CloudFormation stack. RecipeId : The recipe identifier that was used to deploy your application to AWS. Settings : This is a JSON blob that stores the values of all available settings that can be tweaked to adjust the deployment configuration. For more info on how to create your own Deployment settings file , go to Creating a deployment settings file Invoking from CI/CD The --apply switch on the deploy command allows you to specify a deployment settings file. dotnet aws deploy --project-path <PROJECT_PATH> --apply <SETTINGS_FILE_PATH> MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 deploymentsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2517 WeatherForecast.cs \u2517 MyWebApplication.sln To deploy the application with the above directory structure in CI/CD pipeline without any prompts, use the following command: dotnet aws deploy --silent --project-path MyWebApplication/MyWebApplication/MyWebApplication.csproj --apply deploymentsettings.json","title":"Integrating with CI/CD"},{"location":"docs/cicd/cicd/#integrating-with-cicd","text":"You can use AWS Deploy Tool when developing your app using any Continuous Deployment system. Continuous Deployment systems let you automatically build, test and deploy your application each time you check in updates to your source code. Before you can use AWS Deploy Tool in your CD pipeline, you must have required pre-requisites installed and configured in the CD environment.","title":"Integrating with CI/CD"},{"location":"docs/cicd/cicd/#suppressing-prompts-with-silent","text":"To turn off the interactive features, use the -s (--silent) switch. This will ensure the tool never prompts for any questions that could block an automated process. dotnet aws deploy --silent","title":"Suppressing prompts with --silent"},{"location":"docs/cicd/cicd/#creating-a-deployment-settings-file","text":"You can persist the deployment configuration to a JSON file using the --save-settings <SETTINGS_FILE_PATH)> switch. This JSON file can be version controlled and plugged into your CI/CD system for future deployments. Note - The --save-settings switch will only persist settings that have been modified (which means they hold a non-default value). To persist all settings use the --save-all-settings switch. dotnet aws deploy --project-path <PROJECT_PATH> [--save-settings|--save-all-settings] <SETTINGS_FILE_PATH> Note - The SETTINGS_FILE_PATH can be an absolute path or relative to the PROJECT_PATH . Here's an example of a web application with the following directory structure: MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2523 WeatherForecast.cs \u2517 MyWebApplication.sln To perform a deployment and also persist the deployment configuration to a JSON file, use the following command: dotnet aws deploy --project-path MyWebApplication/MyWebApplication/MyWebApplication.csproj --save-settings deploymentsettings.json This will create a JSON file at MyWebApplication/MyWebApplication/deploymentsettings.json with the following structure: { \"AWSProfile\": <AWS_PROFILE>, \"AWSRegion\": <AWS_REGION>, \"ApplicationName\": <APPLICATION_NAME>, \"RecipeId\": <RECIPE_ID>, \"Settings\": <JSON_BLOB> } AWSProfile : The name of the AWS profile that was used during deployment. AWSRegion : The name of the AWS region where the deployed application is hosted. ApplicationName : The name that is used to identify your cloud application within AWS. If the application is deployed via AWS CDK, then this name points to the CloudFormation stack. RecipeId : The recipe identifier that was used to deploy your application to AWS. Settings : This is a JSON blob that stores the values of all available settings that can be tweaked to adjust the deployment configuration. For more info on how to create your own Deployment settings file , go to Creating a deployment settings file","title":"Creating a deployment settings file"},{"location":"docs/cicd/cicd/#invoking-from-cicd","text":"The --apply switch on the deploy command allows you to specify a deployment settings file. dotnet aws deploy --project-path <PROJECT_PATH> --apply <SETTINGS_FILE_PATH> MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 deploymentsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2517 WeatherForecast.cs \u2517 MyWebApplication.sln To deploy the application with the above directory structure in CI/CD pipeline without any prompts, use the following command: dotnet aws deploy --silent --project-path MyWebApplication/MyWebApplication/MyWebApplication.csproj --apply deploymentsettings.json","title":"Invoking from CI/CD"},{"location":"docs/cicd/deployment-settings-file/","text":"Creating a deployment settings file What is a deployment settings file A deployment settings file allows you to define the deployment settings of your application in a JSON format. This JSON file can be version controlled and plugged into your CI/CD system for future deployments. Deployment settings files could be used as a way to automate your deployments or use them in a CI/CD setting where you would define all the settings that you need to apply for your deployment and then use the --apply flag on the CLI to link to the deployment setting file. By doing this, the AWS .NET deployment tool reads all the settings you have defined and applies them to the deployment. You will need to do a final confirmation to initiate the deployment in the CLI. However, you can bypass the confirmation by making the deployment a silent one. This can be done by adding the --silent flag which will turn off any prompts. The deployment settings file has the following structure: { \"AWSProfile\": <AWS_PROFILE>, \"AWSRegion\": <AWS_REGION>, \"ApplicationName\": <APPLICATION_NAME>, \"RecipeId\": <RECIPE_ID>, \"Settings\": <JSON_BLOB> } AWSProfile : The name of the AWS profile that will be used during deployment. AWSRegion : The name of the AWS region where the deployed application is hosted. ApplicationName : The name that is used to identify your cloud application within AWS. If the application is deployed via AWS CDK, then this name points to the CloudFormation stack. RecipeId : The recipe identifier that will be used to deploy your application to AWS. Settings : This is a JSON blob that stores the values of all available settings that can be tweaked to adjust the deployment configuration. This is represented as a JSON object that contains the deployment setting IDs and values as a key/pair configuration. Note: AWSProfile, AWSRegion and ApplicationName are optional and can be overriden by using the appropriate command line switches. This enables users to craft a deployment settings file that could be used for multiple AWS profiles and regions. An example of overriding AWSProfile, AWSRegion and ApplicationName in the CLI: dotnet aws deploy --application-name WebApp1 --profile default --region us-west-2 Each recipe has its own set of settings that can be configured. The following pages in this section list the settings for each recipe that can be used to fill in the Settings section of the file. Example of a deployment settings file An example of what a deployment settings file would look like: { \"AWSProfile\": \"default\", \"AWSRegion\": \"us-west-2\", \"ApplicationName\": \"WebApp1\", \"RecipeId\": \"AspNetAppEcsFargate\", \"Settings\": { \"ECSCluster\": { \"CreateNew\": true, \"NewClusterName\": \"WebApp1-Cluster\" }, \"ECSServiceName\": \"WebApp1-service\", \"DesiredCount\": 3, \"ApplicationIAMRole\": { \"CreateNew\": true } } } Settings that contain child settings under them are represented as another JSON object similar to the example provided above. How to create a deployment settings file Create a new JSON file. Add the 3 properties AWSProfile, AWSRegion and ApplicationName . These are generic and not tied to a specific Recipe file. AWSProfile : The name of the AWS profile that will be used during deployment. AWSRegion : The name of the AWS region where the deployed application is hosted. ApplicationName : The name that is used to identify your cloud application within AWS. If the application is deployed via AWS CDK, then this name points to the CloudFormation stack. Pick a Recipe from the Deployment Recipes section in the navigation to use for your deployment. A Recipe defines the .NET application type and the AWS compute to deploy it to. For example ASP.NET Core App to Amazon ECS using AWS Fargate . Add a Settings object to define deployment settings. To set the ECS Service Name , get the ID from the Recipe which is ECSServiceName . The value needs to be the same type as the Type of setting. ECS Service Name has a type String , so give it a value WebApp1-service . To set ECS Cluster , the ID is ECSCluster and the setting has a type Object . The value of Object types is another JSON blob representing the setting ID and value of the Object's children settings . To set the 2 children settings Create New ECS Cluster and New Cluster Name , use the IDs CreateNew and NewClusterName respectively. Create New ECS Cluster has a type Bool so we can set true or false , and New Cluster Name is a String . The deployment settings file will look like this: { \"AWSProfile\": \"default\", \"AWSRegion\": \"us-west-2\", \"ApplicationName\": \"WebApp1\", \"RecipeId\": \"AspNetAppEcsFargate\", \"Settings\": { \"ECSCluster\": { \"CreateNew\": true, \"NewClusterName\": \"WebApp1-Cluster\" }, \"ECSServiceName\": \"WebApp1-service\" } } Keep adding more settings by using the Recipe you selected as reference and be mindful of the type of setting you are setting.","title":"Creating a deployment settings file"},{"location":"docs/cicd/deployment-settings-file/#creating-a-deployment-settings-file","text":"","title":"Creating a deployment settings file"},{"location":"docs/cicd/deployment-settings-file/#what-is-a-deployment-settings-file","text":"A deployment settings file allows you to define the deployment settings of your application in a JSON format. This JSON file can be version controlled and plugged into your CI/CD system for future deployments. Deployment settings files could be used as a way to automate your deployments or use them in a CI/CD setting where you would define all the settings that you need to apply for your deployment and then use the --apply flag on the CLI to link to the deployment setting file. By doing this, the AWS .NET deployment tool reads all the settings you have defined and applies them to the deployment. You will need to do a final confirmation to initiate the deployment in the CLI. However, you can bypass the confirmation by making the deployment a silent one. This can be done by adding the --silent flag which will turn off any prompts. The deployment settings file has the following structure: { \"AWSProfile\": <AWS_PROFILE>, \"AWSRegion\": <AWS_REGION>, \"ApplicationName\": <APPLICATION_NAME>, \"RecipeId\": <RECIPE_ID>, \"Settings\": <JSON_BLOB> } AWSProfile : The name of the AWS profile that will be used during deployment. AWSRegion : The name of the AWS region where the deployed application is hosted. ApplicationName : The name that is used to identify your cloud application within AWS. If the application is deployed via AWS CDK, then this name points to the CloudFormation stack. RecipeId : The recipe identifier that will be used to deploy your application to AWS. Settings : This is a JSON blob that stores the values of all available settings that can be tweaked to adjust the deployment configuration. This is represented as a JSON object that contains the deployment setting IDs and values as a key/pair configuration. Note: AWSProfile, AWSRegion and ApplicationName are optional and can be overriden by using the appropriate command line switches. This enables users to craft a deployment settings file that could be used for multiple AWS profiles and regions. An example of overriding AWSProfile, AWSRegion and ApplicationName in the CLI: dotnet aws deploy --application-name WebApp1 --profile default --region us-west-2 Each recipe has its own set of settings that can be configured. The following pages in this section list the settings for each recipe that can be used to fill in the Settings section of the file.","title":"What is a deployment settings file"},{"location":"docs/cicd/deployment-settings-file/#example-of-a-deployment-settings-file","text":"An example of what a deployment settings file would look like: { \"AWSProfile\": \"default\", \"AWSRegion\": \"us-west-2\", \"ApplicationName\": \"WebApp1\", \"RecipeId\": \"AspNetAppEcsFargate\", \"Settings\": { \"ECSCluster\": { \"CreateNew\": true, \"NewClusterName\": \"WebApp1-Cluster\" }, \"ECSServiceName\": \"WebApp1-service\", \"DesiredCount\": 3, \"ApplicationIAMRole\": { \"CreateNew\": true } } } Settings that contain child settings under them are represented as another JSON object similar to the example provided above.","title":"Example of a deployment settings file"},{"location":"docs/cicd/deployment-settings-file/#how-to-create-a-deployment-settings-file","text":"Create a new JSON file. Add the 3 properties AWSProfile, AWSRegion and ApplicationName . These are generic and not tied to a specific Recipe file. AWSProfile : The name of the AWS profile that will be used during deployment. AWSRegion : The name of the AWS region where the deployed application is hosted. ApplicationName : The name that is used to identify your cloud application within AWS. If the application is deployed via AWS CDK, then this name points to the CloudFormation stack. Pick a Recipe from the Deployment Recipes section in the navigation to use for your deployment. A Recipe defines the .NET application type and the AWS compute to deploy it to. For example ASP.NET Core App to Amazon ECS using AWS Fargate . Add a Settings object to define deployment settings. To set the ECS Service Name , get the ID from the Recipe which is ECSServiceName . The value needs to be the same type as the Type of setting. ECS Service Name has a type String , so give it a value WebApp1-service . To set ECS Cluster , the ID is ECSCluster and the setting has a type Object . The value of Object types is another JSON blob representing the setting ID and value of the Object's children settings . To set the 2 children settings Create New ECS Cluster and New Cluster Name , use the IDs CreateNew and NewClusterName respectively. Create New ECS Cluster has a type Bool so we can set true or false , and New Cluster Name is a String . The deployment settings file will look like this: { \"AWSProfile\": \"default\", \"AWSRegion\": \"us-west-2\", \"ApplicationName\": \"WebApp1\", \"RecipeId\": \"AspNetAppEcsFargate\", \"Settings\": { \"ECSCluster\": { \"CreateNew\": true, \"NewClusterName\": \"WebApp1-Cluster\" }, \"ECSServiceName\": \"WebApp1-service\" } } Keep adding more settings by using the Recipe you selected as reference and be mindful of the type of setting you are setting.","title":"How to create a deployment settings file"},{"location":"docs/cicd/recipes/ASP.NET%20Core%20App%20to%20AWS%20App%20Runner/","text":"Recipe ID: AspNetAppAppRunner Recipe Description: This ASP.NET Core application will be built as a container image on Linux and deployed to AWS App Runner, a fully managed service for web applications and APIs. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your web application as a Linux container image on a fully managed environment. Settings: Service Name ID: ServiceName Description: The name of the AWS App Runner service. Type: String Container Port ID: Port Description: The port the container is listening for requests on. Type: Int Start Command ID: StartCommand Description: Override the start command from the image's default start command. Type: String Application IAM Role ID: ApplicationIAMRole Description: The Identity and Access Management (IAM) role that provides AWS credentials to the application to access AWS services. Type: Object Settings: Create New Role ID: CreateNew Description: Do you want to create a new role? Type: Bool Existing Role ARN ID: RoleArn Description: The ARN of the existing role to use. Type: String Service Access IAM Role ID: ServiceAccessIAMRole Description: The Identity and Access Management (IAM) role that provides gives the AWS App Runner service access to pull the container image from ECR. Type: Object Settings: Create New Role ID: CreateNew Description: Do you want to create a new role? Type: Bool Existing Role ARN ID: RoleArn Description: The ARN of the existing role to use. Type: String CPU ID: Cpu Description: The number of CPU units reserved for each instance of your App Runner service. Type: String Memory ID: Memory Description: The amount of memory reserved for each instance of your App Runner service. Type: String Encryption KMS Key ID: EncryptionKmsKey Description: The ARN of the KMS key that's used for encryption of application logs. Type: String Health Check Protocol ID: HealthCheckProtocol Description: The IP protocol that App Runner uses to perform health checks for your service. Type: String Health Check Path ID: HealthCheckPath Description: The URL that health check requests are sent to. Type: String Health Check Interval ID: HealthCheckInterval Description: The time interval, in seconds, between health checks. Type: Int Health Check Timeout ID: HealthCheckTimeout Description: The time, in seconds, to wait for a health check response before deciding it failed. Type: Int Health Check Healthy Threshold ID: HealthCheckHealthyThreshold Description: The number of consecutive checks that must succeed before App Runner decides that the service is healthy. Type: Int Health Check Unhealthy Threshold ID: HealthCheckUnhealthyThreshold Description: The number of consecutive checks that must fail before App Runner decides that the service is unhealthy. Type: Int VPC Connector ID: VPCConnector Description: App Runner requires this resource when you want to associate your App Runner service to a custom Amazon Virtual Private Cloud (Amazon VPC). Type: Object Settings: Use VPC Connector ID: UseVPCConnector Description: Do you want to use a VPC Connector to connect to a VPC? Type: Bool Create New VPC Connector ID: CreateNew Description: Do you want to create a new VPC Connector? Type: Bool Existing VPC Connector ID ID: VpcConnectorId Description: The ID of the existing VPC Connector to use. Type: String Create New VPC ID: CreateNewVpc Description: Do you want to create a new VPC to use for the VPC Connector? Type: Bool VPC ID ID: VpcId Description: A list of VPC IDs that App Runner should use when it associates your service with a custom Amazon VPC. Type: String Subnets ID: Subnets Description: A list of IDs of subnets that App Runner should use when it associates your service with a custom Amazon VPC. Specify IDs of subnets of a single Amazon VPC. App Runner determines the Amazon VPC from the subnets you specify. Type: List Security Groups ID: SecurityGroups Description: A list of IDs of security groups that App Runner should use for access to AWS resources under the specified subnets. If not specified, App Runner uses the default security group of the Amazon VPC. The default security group allows all outbound traffic. Type: List Environment Variables ID: AppRunnerEnvironmentVariables Description: Configure environment properties for your application. Type: KeyValue Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Docker Build Args ID: DockerBuildArgs Description: The list of additional options to append to the docker build command. Type: String Dockerfile Path ID: DockerfilePath Description: Specify a path to a Dockerfile as either an absolute path or a path relative to the project. Type: String Docker Execution Directory ID: DockerExecutionDirectory Description: Specifies the docker execution directory where the docker build command will be executed from. Type: String ECR Repository Name ID: ECRRepositoryName Description: Specifies the ECR repository where the Docker images will be stored Type: String","title":"ASP.NET Core App to AWS App Runner"},{"location":"docs/cicd/recipes/ASP.NET%20Core%20App%20to%20AWS%20Elastic%20Beanstalk%20on%20Linux/","text":"Recipe ID: AspNetAppElasticBeanstalkLinux Recipe Description: This ASP.NET Core application will be built and deployed to AWS Elastic Beanstalk on Linux. Recommended if you want to deploy your application directly to EC2 hosts, not as a container image. Settings: Elastic Beanstalk Application ID: BeanstalkApplication Description: The Elastic Beanstalk application. Type: Object Settings: Create new Elastic Beanstalk application ID: CreateNew Description: Do you want to create new application? Type: Bool Application Name ID: ApplicationName Description: The Elastic Beanstalk application name. Type: String Application Name ID: ExistingApplicationName Description: The Elastic Beanstalk application name. Type: String Environment Name ID: BeanstalkEnvironment Description: The Elastic Beanstalk environment name. Type: Object Settings: Environment Name ID: EnvironmentName Description: The Elastic Beanstalk environment name. Type: String EC2 Instance Type ID: InstanceType Description: The EC2 instance type of the EC2 instances created for the environment. Type: String Access to IMDS v1 ID: IMDSv1Access Description: Access to IMDS v1; Default means new deployments will disable IMDSv1, redeployments leave the setting at its current value. Type: String Environment Type ID: EnvironmentType Description: The type of environment to create; for example, a single instance for development work or load balanced for production. Type: String Load Balancer Type ID: LoadBalancerType Description: The type of load balancer for your environment. Type: String Load Balancer Scheme ID: LoadBalancerScheme Description: Specify \"Internal\" if your application serves requests only from connected VPCs. \"Public\" load balancers serve requests from the Internet. Type: String Application IAM Role ID: ApplicationIAMRole Description: The Identity and Access Management (IAM) role that provides AWS credentials to the application to access AWS services. Type: Object Settings: Create New Role ID: CreateNew Description: Do you want to create a new role? Type: Bool Existing Role ARN ID: RoleArn Description: The ARN of the existing role to use. Type: String Service IAM Role ID: ServiceIAMRole Description: A service role is the IAM role that Elastic Beanstalk assumes when calling other services on your behalf. Type: Object Settings: Create New Role ID: CreateNew Description: Do you want to create a new role? Type: Bool Existing Role ARN ID: RoleArn Description: The ARN of the existing role to use. Type: String Key Pair ID: EC2KeyPair Description: The EC2 key pair used to SSH into EC2 instances for the Elastic Beanstalk environment. Type: String Beanstalk Platform ID: ElasticBeanstalkPlatformArn Description: The name of the Elastic Beanstalk platform to use with the environment. Type: String Managed Platform Updates ID: ElasticBeanstalkManagedPlatformUpdates Description: Enable managed platform updates to apply platform updates automatically during a weekly maintenance window that you choose. Your application stays available during the update process. Type: Object Settings: Enable Managed Platform Updates ID: ManagedActionsEnabled Description: Do you want to enable Managed Platform Updates? Type: Bool Preferred Start Time ID: PreferredStartTime Description: Configure a maintenance window for managed actions in UTC. Valid values are Day and time in the 'day:hour:minute' format. For example, 'Sun:00:00'. Type: String Update Level ID: UpdateLevel Description: The highest level of update to apply with managed platform updates. Platforms are versioned major.minor.patch. For example, 2.0.8 has a major version of 2, a minor version of 0, and a patch version of 8. Type: String Enable AWS X-Ray Tracing Support ID: XRayTracingSupportEnabled Description: AWS X-Ray is a service that collects data about requests that your application serves, and provides tools you can use to view, filter, and gain insights into that data to identify issues and opportunities for optimization. Do you want to enable AWS X-Ray tracing support? Type: Bool Reverse Proxy ID: ReverseProxy Description: By default Nginx is used as a reverse proxy in front of the .NET Core web server Kestrel. To use Kestrel as the front facing web server then select none as the reverse proxy. Type: String Enhanced Health Reporting ID: EnhancedHealthReporting Description: Enhanced health reporting provides free real-time application and operating system monitoring of the instances and other resources in your environment. Type: String Health Check URL ID: HealthCheckURL Description: Customize the load balancer health check to ensure that your application, and not just the web server, is in a good state. Type: String Rolling Updates ID: ElasticBeanstalkRollingUpdates Description: When a configuration change requires replacing instances, Elastic Beanstalk can perform the update in batches to avoid downtime while the change is propagated. During a rolling update, capacity is only reduced by the size of a single batch, which you can configure. Elastic Beanstalk takes one batch of instances out of service, terminates them, and then launches a batch with the new configuration. After the new batch starts serving requests, Elastic Beanstalk moves on to the next batch. Type: Object Settings: Enable Rolling Updates ID: RollingUpdatesEnabled Description: Do you want to enable Rolling Updates? Type: Bool Rolling Update Type ID: RollingUpdateType Description: This includes three types: time-based rolling updates, health-based rolling updates, and immutable updates. Time-based rolling updates apply a PauseTime between batches. Health-based rolling updates wait for new instances to pass health checks before moving on to the next batch. Immutable updates launch a full set of instances in a new Auto Scaling group. Type: String Max Batch Size ID: MaxBatchSize Description: The number of instances included in each batch of the rolling update. Type: Int Min Instances In Service ID: MinInstancesInService Description: The minimum number of instances that must be in service within the Auto Scaling group while other instances are terminated. Type: Int Pause Time ID: PauseTime Description: The amount of time (in seconds, minutes, or hours) the Elastic Beanstalk service waits after it completed updates to one batch of instances and before it continues on to the next batch. (ISO8601 duration format: PT#H#M#S where each # is the number of hours, minutes, and/or seconds, respectively.) Type: String Timeout ID: Timeout Description: The maximum amount of time (in minutes or hours) to wait for all instances in a batch of instances to pass health checks before canceling the update. (ISO8601 duration format: PT#H#M#S where each # is the number of hours, minutes, and/or seconds, respectively.) Type: String CName Prefix ID: CNamePrefix Description: If specified, the environment attempts to use this value as the prefix for the CNAME in your Elastic Beanstalk environment URL. If not specified, the CNAME is generated automatically by appending a random alphanumeric string to the environment name. Type: String Environment Variables ID: ElasticBeanstalkEnvironmentVariables Description: Configure environment properties for your application. Type: KeyValue Virtual Private Cloud (VPC) ID: VPC Description: A VPC enables you to launch the application into a virtual network that you've defined Type: Object Settings: **Use a VPC ** ID: UseVPC Description: Do you want to use a Virtual Private Cloud (VPC)? Type: Bool Create New VPC ID: CreateNew Description: Do you want to create a new VPC? Type: Bool VPC ID ID: VpcId Description: A list of VPC IDs that Elastic Beanstalk should use when it associates your service with a custom Amazon VPC. Type: String EC2 Instance Subnets ID: Subnets Description: A list of IDs of subnets that Elastic Beanstalk should use when it associates your environment with a custom Amazon VPC. Specify IDs of subnets of a single Amazon VPC. Type: List Security Groups ID: SecurityGroups Description: Lists the Amazon EC2 security groups to assign to the EC2 instances in the Auto Scaling group to define firewall rules for the instances. Type: List Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Dotnet Build Configuration ID: DotnetBuildConfiguration Description: The build configuration to use for the dotnet build Type: String Dotnet Publish Args ID: DotnetPublishArgs Description: The list of additional dotnet publish args passed to the target application. Type: String Self Contained Build ID: SelfContainedBuild Description: Publishing your app as self-contained produces an application that includes the .NET runtime and libraries. Users can run it on a machine that doesn't have the .NET runtime installed. Type: Bool","title":"ASP.NET Core App to AWS Elastic Beanstalk on Linux"},{"location":"docs/cicd/recipes/ASP.NET%20Core%20App%20to%20AWS%20Elastic%20Beanstalk%20on%20Windows/","text":"Recipe ID: AspNetAppElasticBeanstalkWindows Recipe Description: This ASP.NET Core application will be built and deployed to AWS Elastic Beanstalk on Windows. Recommended if you do not want to deploy your application as a container image. Settings: Elastic Beanstalk Application ID: BeanstalkApplication Description: The Elastic Beanstalk application. Type: Object Settings: Create new Elastic Beanstalk application ID: CreateNew Description: Do you want to create new application? Type: Bool Application Name ID: ApplicationName Description: The Elastic Beanstalk application name. Type: String Application Name ID: ExistingApplicationName Description: The Elastic Beanstalk application name. Type: String Environment Name ID: EnvironmentName Description: The Elastic Beanstalk environment name. Type: String EC2 Instance Type ID: InstanceType Description: The EC2 instance type of the EC2 instances created for the environment. Type: String Access to IMDS v1 ID: IMDSv1Access Description: Access to IMDS v1; Default means new deployments will disable IMDSv1, redeployments leave the setting at its current value. Type: String Environment Type ID: EnvironmentType Description: The type of environment to create; for example, a single instance for development work or load balanced for production. Type: String Load Balancer Type ID: LoadBalancerType Description: The type of load balancer for your environment. Type: String Load Balancer Scheme ID: LoadBalancerScheme Description: Specify \"Internal\" if your application serves requests only from connected VPCs. \"Public\" load balancers serve requests from the Internet. Type: String Application IAM Role ID: ApplicationIAMRole Description: The Identity and Access Management (IAM) role that provides AWS credentials to the application to access AWS services. Type: Object Settings: Create New Role ID: CreateNew Description: Do you want to create a new role? Type: Bool Existing Role ARN ID: RoleArn Description: The ARN of the existing role to use. Type: String Service IAM Role ID: ServiceIAMRole Description: A service role is the IAM role that Elastic Beanstalk assumes when calling other services on your behalf. Type: Object Settings: Create New Role ID: CreateNew Description: Do you want to create a new role? Type: Bool Existing Role ARN ID: RoleArn Description: The ARN of the existing role to use. Type: String Key Pair ID: EC2KeyPair Description: The EC2 key pair used to SSH into EC2 instances for the Elastic Beanstalk environment. Type: String Beanstalk Platform ID: ElasticBeanstalkPlatformArn Description: The name of the Elastic Beanstalk platform to use with the environment. Type: String Managed Platform Updates ID: ElasticBeanstalkManagedPlatformUpdates Description: Enable managed platform updates to apply platform updates automatically during a weekly maintenance window that you choose. Your application stays available during the update process. Type: Object Settings: Enable Managed Platform Updates ID: ManagedActionsEnabled Description: Do you want to enable Managed Platform Updates? Type: Bool Preferred Start Time ID: PreferredStartTime Description: Configure a maintenance window for managed actions in UTC. Valid values are Day and time in the 'day:hour:minute' format. For example, 'Sun:00:00'. Type: String Update Level ID: UpdateLevel Description: The highest level of update to apply with managed platform updates. Platforms are versioned major.minor.patch. For example, 2.0.8 has a major version of 2, a minor version of 0, and a patch version of 8. Type: String Enable AWS X-Ray Tracing Support ID: XRayTracingSupportEnabled Description: AWS X-Ray is a service that collects data about requests that your application serves, and provides tools you can use to view, filter, and gain insights into that data to identify issues and opportunities for optimization. Do you want to enable AWS X-Ray tracing support? Type: Bool IIS Web Site ID: IISWebSite Description: The IIS Web Site the application will be installed in. Type: String IIS Application Path ID: IISAppPath Description: The IIS application path that will be the root of the application. Type: String Enhanced Health Reporting ID: EnhancedHealthReporting Description: Enhanced health reporting provides free real-time application and operating system monitoring of the instances and other resources in your environment. Type: String Health Check URL ID: HealthCheckURL Description: Customize the load balancer health check to ensure that your application, and not just the web server, is in a good state. Type: String Rolling Updates ID: ElasticBeanstalkRollingUpdates Description: When a configuration change requires replacing instances, Elastic Beanstalk can perform the update in batches to avoid downtime while the change is propagated. During a rolling update, capacity is only reduced by the size of a single batch, which you can configure. Elastic Beanstalk takes one batch of instances out of service, terminates them, and then launches a batch with the new configuration. After the new batch starts serving requests, Elastic Beanstalk moves on to the next batch. Type: Object Settings: Enable Rolling Updates ID: RollingUpdatesEnabled Description: Do you want to enable Rolling Updates? Type: Bool Rolling Update Type ID: RollingUpdateType Description: This includes three types: time-based rolling updates, health-based rolling updates, and immutable updates. Time-based rolling updates apply a PauseTime between batches. Health-based rolling updates wait for new instances to pass health checks before moving on to the next batch. Immutable updates launch a full set of instances in a new Auto Scaling group. Type: String Max Batch Size ID: MaxBatchSize Description: The number of instances included in each batch of the rolling update. Type: Int Min Instances In Service ID: MinInstancesInService Description: The minimum number of instances that must be in service within the Auto Scaling group while other instances are terminated. Type: Int Pause Time ID: PauseTime Description: The amount of time (in seconds, minutes, or hours) the Elastic Beanstalk service waits after it completed updates to one batch of instances and before it continues on to the next batch. (ISO8601 duration format: PT#H#M#S where each # is the number of hours, minutes, and/or seconds, respectively.) Type: String Timeout ID: Timeout Description: The maximum amount of time (in minutes or hours) to wait for all instances in a batch of instances to pass health checks before canceling the update. (ISO8601 duration format: PT#H#M#S where each # is the number of hours, minutes, and/or seconds, respectively.) Type: String CName Prefix ID: CNamePrefix Description: If specified, the environment attempts to use this value as the prefix for the CNAME in your Elastic Beanstalk environment URL. If not specified, the CNAME is generated automatically by appending a random alphanumeric string to the environment name. Type: String Environment Variables ID: ElasticBeanstalkEnvironmentVariables Description: Configure environment properties for your application. Type: KeyValue Virtual Private Cloud (VPC) ID: VPC Description: A VPC enables you to launch the application into a virtual network that you've defined Type: Object Settings: **Use a VPC ** ID: UseVPC Description: Do you want to use a Virtual Private Cloud (VPC)? Type: Bool Create New VPC ID: CreateNew Description: Do you want to create a new VPC? Type: Bool VPC ID ID: VpcId Description: A list of VPC IDs that Elastic Beanstalk should use when it associates your service with a custom Amazon VPC. Type: String EC2 Instance Subnets ID: Subnets Description: A list of IDs of subnets that Elastic Beanstalk should use when it associates your environment with a custom Amazon VPC. Specify IDs of subnets of a single Amazon VPC. Type: List Security Groups ID: SecurityGroups Description: Lists the Amazon EC2 security groups to assign to the EC2 instances in the Auto Scaling group to define firewall rules for the instances. Type: List Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Dotnet Build Configuration ID: DotnetBuildConfiguration Description: The build configuration to use for the dotnet build Type: String Dotnet Publish Args ID: DotnetPublishArgs Description: The list of additional dotnet publish args passed to the target application. Type: String Self Contained Build ID: SelfContainedBuild Description: Publishing your app as self-contained produces an application that includes the .NET runtime and libraries. Users can run it on a machine that doesn't have the .NET runtime installed. Type: Bool","title":"ASP.NET Core App to AWS Elastic Beanstalk on Windows"},{"location":"docs/cicd/recipes/ASP.NET%20Core%20App%20to%20Amazon%20ECS%20using%20AWS%20Fargate/","text":"Recipe ID: AspNetAppEcsFargate Recipe Description: This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your application as a container image on Linux. Settings: ECS Cluster ID: ECSCluster Description: The ECS cluster used for the deployment. Type: Object Settings: Create New ECS Cluster ID: CreateNew Description: Do you want to create a new ECS cluster? Type: Bool Existing Cluster ARN ID: ClusterArn Description: The ARN of the existing cluster to use. Type: String New Cluster Name ID: NewClusterName Description: The name of the new cluster to create. Type: String ECS Service Name ID: ECSServiceName Description: The name of the ECS service running in the cluster. Type: String Desired Task Count ID: DesiredCount Description: The desired number of ECS tasks to run for the service. Type: Int Container Port ID: Port Description: The port the container is listening for requests on. Type: Int Application IAM Role ID: ApplicationIAMRole Description: The Identity and Access Management (IAM) role that provides AWS credentials to the application to access AWS services. Type: Object Settings: Create New Role ID: CreateNew Description: Do you want to create a new role? Type: Bool Existing Role ARN ID: RoleArn Description: The ARN of the existing role to use. Type: String Virtual Private Cloud (VPC) ID: Vpc Description: A VPC enables you to launch the application into a virtual network that you've defined. Type: Object Settings: Use default VPC ID: IsDefault Description: Do you want to use the default VPC for the deployment? Type: Bool Create New VPC ID: CreateNew Description: Do you want to create a new VPC? Type: Bool Existing VPC ID ID: VpcId Description: The ID of the existing VPC to use. Type: String ECS Service Security Groups ID: AdditionalECSServiceSecurityGroups Description: A list of EC2 security groups to assign to the ECS service. This is commonly used to provide access to Amazon RDS databases running in their own security groups. Type: List Task CPU ID: TaskCpu Description: The number of CPU units used by the task. See the following for details on CPU values: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html#fargate-task-defs Type: Int Task Memory ID: TaskMemory Description: The amount of memory (in MB) used by the task. See the following for details on memory values: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html#fargate-task-defs Type: Int Elastic Load Balancer ID: LoadBalancer Description: Load Balancer the ECS Service will register tasks to. Type: Object Settings: Create New Load Balancer ID: CreateNew Description: Do you want to create a new Load Balancer? Type: Bool Existing Load Balancer ARN ID: ExistingLoadBalancerArn Description: The ARN of an existing load balancer to use. Type: String Deregistration delay (seconds) ID: DeregistrationDelayInSeconds Description: The amount of time to allow requests to finish before deregistering ECS tasks. Type: Int Health Check Path ID: HealthCheckPath Description: The ping path destination where Elastic Load Balancing sends health check requests. Type: String Health Check Timeout ID: HealthCheckTimeout Description: The amount of time, in seconds, during which no response from a target means a failed health check. Type: Int Health Check Interval ID: HealthCheckInternval Description: The approximate interval, in seconds, between health checks of an individual instance. Type: Int Healthy Threshold Count ID: HealthyThresholdCount Description: The number of consecutive health check successes required before considering an unhealthy target healthy. Type: Int Unhealthy Threshold Count ID: UnhealthyThresholdCount Description: The number of consecutive health check successes required before considering an unhealthy target unhealthy. Type: Int Type of Listener Condition ID: ListenerConditionType Description: The type of listener rule to create to direct traffic to ECS service. Type: String Listener Condition Path Pattern ID: ListenerConditionPathPattern Description: The resource path pattern to use for the listener rule. (i.e. \"/api/*\") Type: String Listener Condition Priority ID: ListenerConditionPriority Description: Priority of the condition rule. The value must be unique for the Load Balancer listener. Type: Int Internet-Facing ID: InternetFacing Description: Should the load balancer have an internet-routable address? Internet-facing load balancers can route requests from clients over the internet. Internal load balancers can route requests only from clients with access to the VPC. Type: Bool AutoScaling ID: AutoScaling Description: The AutoScaling configuration for the ECS service. Type: Object Settings: Enable ID: Enabled Description: Do you want to enable AutoScaling? Type: Bool Minimum Capacity ID: MinCapacity Description: The minimum number of ECS tasks handling the demand for the ECS service. Type: Int Maximum Capacity ID: MaxCapacity Description: The maximum number of ECS tasks handling the demand for the ECS service. Type: Int AutoScaling Metric ID: ScalingType Description: The metric to monitor for scaling changes. Type: String CPU Target Utilization ID: CpuTypeTargetUtilizationPercent Description: The target cpu utilization percentage that triggers a scaling change. Type: Double Scale in cooldown (seconds) ID: CpuTypeScaleInCooldownSeconds Description: The amount of time, in seconds, after a scale in activity completes before another scale in activity can start. Type: Int Scale out cooldown (seconds) ID: CpuTypeScaleOutCooldownSeconds Description: The amount of time, in seconds, after a scale out activity completes before another scale out activity can start. Type: Int Memory Target Utilization ID: MemoryTypeTargetUtilizationPercent Description: The target memory utilization percentage that triggers a scaling change. Type: Double Scale in cooldown (seconds) ID: MemoryTypeScaleInCooldownSeconds Description: The amount of time, in seconds, after a scale in activity completes before another scale in activity can start. Type: Int Scale out cooldown (seconds) ID: MemoryTypeScaleOutCooldownSeconds Description: The amount of time, in seconds, after a scale out activity completes before another scale out activity can start. Type: Int Request per task ID: RequestTypeRequestsPerTarget Description: The number of request per ECS task that triggers a scaling change. Type: Int Scale in cooldown (seconds) ID: RequestTypeScaleInCooldownSeconds Description: The amount of time, in seconds, after a scale in activity completes before another scale in activity can start. Type: Int Scale out cooldown (seconds) ID: RequestTypeScaleOutCooldownSeconds Description: The amount of time, in seconds, after a scale out activity completes before another scale out activity can start. Type: Int Environment Variables ID: ECSEnvironmentVariables Description: Configure environment properties for your application. Type: KeyValue Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Docker Build Args ID: DockerBuildArgs Description: The list of additional options to append to the docker build command. Type: String Dockerfile Path ID: DockerfilePath Description: Specify a path to a Dockerfile as either an absolute path or a path relative to the project. Type: String Docker Execution Directory ID: DockerExecutionDirectory Description: Specifies the docker execution directory where the docker build command will be executed from. Type: String ECR Repository Name ID: ECRRepositoryName Description: Specifies the ECR repository where the Docker images will be stored Type: String","title":"ASP.NET Core App to Amazon ECS using AWS Fargate"},{"location":"docs/cicd/recipes/ASP.NET%20Core%20App%20to%20Existing%20AWS%20Elastic%20Beanstalk%20Environment/","text":"Recipe ID: AspNetAppExistingBeanstalkEnvironment Recipe Description: This ASP.NET Core application will be built and deployed to an existing AWS Elastic Beanstalk environment. Recommended if you want to deploy your application directly to EC2 hosts, not as a container image. Settings: Enhanced Health Reporting ID: EnhancedHealthReporting Description: Enhanced health reporting provides free real-time application and operating system monitoring of the instances and other resources in your environment. Type: String Enable AWS X-Ray Tracing Support ID: XRayTracingSupportEnabled Description: AWS X-Ray is a service that collects data about requests that your application serves, and provides tools you can use to view, filter, and gain insights into that data to identify issues and opportunities for optimization. Do you want to enable AWS X-Ray tracing support? Type: Bool Reverse Proxy ID: ReverseProxy Description: By default Nginx is used as a reverse proxy in front of the .NET Core web server Kestrel. To use Kestrel as the front facing web server then select none as the reverse proxy. Type: String Health Check URL ID: HealthCheckURL Description: Customize the load balancer health check to ensure that your application, and not just the web server, is in a good state. Type: String Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Dotnet Build Configuration ID: DotnetBuildConfiguration Description: The build configuration to use for the dotnet build Type: String Dotnet Publish Args ID: DotnetPublishArgs Description: The list of additional dotnet publish args passed to the target application. Type: String Self Contained Build ID: SelfContainedBuild Description: Publishing your app as self-contained produces an application that includes the .NET runtime and libraries. Users can run it on a machine that doesn't have the .NET runtime installed. Type: Bool","title":"ASP.NET Core App to Existing AWS Elastic Beanstalk Environment"},{"location":"docs/cicd/recipes/ASP.NET%20Core%20App%20to%20Existing%20AWS%20Elastic%20Beanstalk%20Windows%20Environment/","text":"Recipe ID: AspNetAppExistingBeanstalkWindowsEnvironment Recipe Description: This ASP.NET Core application will be built and deployed to an existing AWS Elastic Beanstalk Windows environment. Recommended if you want to deploy your application directly to EC2 hosts, not as a container image. Settings: IIS Web Site ID: IISWebSite Description: The IIS Web Site the application will be installed in. Type: String IIS Application Path ID: IISAppPath Description: The IIS application path that will be the root of the application. Type: String Enhanced Health Reporting ID: EnhancedHealthReporting Description: Enhanced health reporting provides free real-time application and operating system monitoring of the instances and other resources in your environment. Type: String Enable AWS X-Ray Tracing Support ID: XRayTracingSupportEnabled Description: AWS X-Ray is a service that collects data about requests that your application serves, and provides tools you can use to view, filter, and gain insights into that data to identify issues and opportunities for optimization. Do you want to enable AWS X-Ray tracing support? Type: Bool Health Check URL ID: HealthCheckURL Description: Customize the load balancer health check to ensure that your application, and not just the web server, is in a good state. Type: String Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Dotnet Build Configuration ID: DotnetBuildConfiguration Description: The build configuration to use for the dotnet build Type: String Dotnet Publish Args ID: DotnetPublishArgs Description: The list of additional dotnet publish args passed to the target application. Type: String Self Contained Build ID: SelfContainedBuild Description: Publishing your app as self-contained produces an application that includes the .NET runtime and libraries. Users can run it on a machine that doesn't have the .NET runtime installed. Type: Bool","title":"ASP.NET Core App to Existing AWS Elastic Beanstalk Windows Environment"},{"location":"docs/cicd/recipes/Blazor%20WebAssembly%20App/","text":"Recipe ID: BlazorWasm Recipe Description: This Blazor WebAssembly application will be built and hosted in a new Amazon Simple Storage Service (Amazon S3) bucket. The Blazor application will be exposed publicly through a CloudFront distribution using the Amazon S3 bucket as the origin. Settings: Index Document ID: IndexDocument Description: The default page to use when the endpoint is accessed with no resource path. Type: String Error Document ID: ErrorDocument Description: The error page to use when an error occurs while accessing the resource path. Type: String Redirect 404 and 403 Errors ID: Redirect404ToRoot Description: Redirect any 404 and 403 requests to the index document. This is useful in Blazor applications that modify the resource path in the browser. If the modified resource path is reused in a new browser it will result in a 403 from Amazon CloudFront since no S3 object exists at that resource path. Type: Bool Backend REST API ID: BackendApi Description: URI to a backend rest api that will be added as an origin to the CloudFront distribution. For example an API Gateway endpoint. Type: Object Settings: Enable ID: Enable Description: Enable adding backend rest api Type: Bool Uri ID: Uri Description: Uri to the backend rest api Type: String Resource Path Pattern ID: ResourcePathPattern Description: The resource path pattern to determine which request go to backend rest api. (i.e. \"/api/*\") Type: String CloudFront Access Logging ID: AccessLogging Description: Configure if and how access logs are written for the CloudFront distribution Type: Object Settings: Enable ID: Enable Description: Enable CloudFront Access Logging Type: Bool Log Cookies ID: LogIncludesCookies Description: Include cookies in access logs Type: Bool Create Logging Bucket ID: CreateLoggingS3Bucket Description: Create new S3 bucket for access logs to be stored. Bucket and logs will be retained after deployment is deleted. Type: Bool Logging Bucket ID: ExistingS3LoggingBucket Description: S3 bucket to use for storing access logs Type: String Logging S3 Key Prefix ID: LoggingS3KeyPrefix Description: Optional S3 key prefix to store access logs (e.g. app-name/) Type: String CloudFront Price Class ID: PriceClass Description: Configure the edge locations that will respond to request for the CloudFront distribution Type: String Enable IPv6 ID: EnableIpv6 Description: Control if IPv6 should be enabled for the CloudFront distribution Type: Bool Maximum HTTP Version ID: MaxHttpVersion Description: The maximum http version that users can use to communicate with the CloudFront distribution Type: String Web ACL Arn ID: WebAclId Description: The AWS WAF (web application firewall) ACL arn Type: String Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Dotnet Build Configuration ID: DotnetBuildConfiguration Description: The build configuration to use for the dotnet build Type: String Dotnet Publish Args ID: DotnetPublishArgs Description: The list of additional dotnet publish args passed to the target application. Type: String Self Contained Build ID: SelfContainedBuild Description: Publishing your app as self-contained produces an application that includes the .NET runtime and libraries. Users can run it on a machine that doesn't have the .NET runtime installed. Type: Bool","title":"Blazor WebAssembly App"},{"location":"docs/cicd/recipes/Container%20Image%20to%20Amazon%20Elastic%20Container%20Registry%20%28ECR%29/","text":"Recipe ID: PushContainerImageEcr Recipe Description: This .NET application will be built using an existing Dockerfile. The Docker container image will then be pushed to Amazon ECR, a fully managed container registry. Settings: Image Tag ID: ImageTag Description: This tag will be associated to the container images which are pushed to Amazon Elastic Container Registry. Type: String Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Docker Build Args ID: DockerBuildArgs Description: The list of additional options to append to the docker build command. Type: String Dockerfile Path ID: DockerfilePath Description: Specify a path to a Dockerfile as either an absolute path or a path relative to the project. Type: String Docker Execution Directory ID: DockerExecutionDirectory Description: Specifies the docker execution directory where the docker build command will be executed from. Type: String ECR Repository Name ID: ECRRepositoryName Description: Specifies the ECR repository where the Docker images will be stored Type: String","title":"Container Image to Amazon Elastic Container Registry (ECR)"},{"location":"docs/cicd/recipes/Scheduled%20Task%20on%20Amazon%20Elastic%20Container%20Service%20%28ECS%29%20using%20AWS%20Fargate/","text":"Recipe ID: ConsoleAppEcsFargateScheduleTask Recipe Description: This .NET Console application will be built using a Dockerfile and deployed as a scheduled task to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy a scheduled task as a container image on Linux. Settings: ECS Cluster ID: ECSCluster Description: The ECS cluster used for the deployment. Type: Object Settings: Create New ECS Cluster ID: CreateNew Description: Do you want to create a new ECS cluster? Type: Bool Existing Cluster ARN ID: ClusterArn Description: The ARN of the existing cluster to use. Type: String New Cluster Name ID: NewClusterName Description: The name of the new cluster to create. Type: String Application IAM Role ID: ApplicationIAMRole Description: The Identity and Access Management (IAM) role that provides AWS credentials to the application to access AWS services. Type: Object Settings: Create New Role ID: CreateNew Description: Do you want to create a new role? Type: Bool Existing Role ARN ID: RoleArn Description: The ARN of the existing role to use. Type: String Task Schedule ID: Schedule Description: The schedule or rate (frequency) that determines when Amazon CloudWatch Events runs the rule. For details about the format for this value, see the CloudWatch Events guide: https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html Type: String Virtual Private Cloud (VPC) ID: Vpc Description: A VPC enables you to launch the application into a virtual network that you've defined. Type: Object Settings: Use default VPC ID: IsDefault Description: Do you want to use the default VPC? Type: Bool Create New VPC ID: CreateNew Description: Do you want to create a new VPC? Type: Bool Existing VPC ID ID: VpcId Description: The ID of the existing VPC to use. Type: String Task CPU ID: TaskCpu Description: The number of CPU units used by the task. See the following for details on CPU values: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html#fargate-task-defs Type: Int Task Memory ID: TaskMemory Description: The amount of memory (in MB) used by the task. See the following for details on memory values: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html#fargate-task-defs Type: Int Environment Variables ID: ECSEnvironmentVariables Description: Configure environment properties for your application. Type: KeyValue Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Docker Build Args ID: DockerBuildArgs Description: The list of additional options to append to the docker build command. Type: String Dockerfile Path ID: DockerfilePath Description: Specify a path to a Dockerfile as either an absolute path or a path relative to the project. Type: String Docker Execution Directory ID: DockerExecutionDirectory Description: Specifies the docker execution directory where the docker build command will be executed from. Type: String ECR Repository Name ID: ECRRepositoryName Description: Specifies the ECR repository where the Docker images will be stored Type: String","title":"Scheduled Task on Amazon Elastic Container Service (ECS) using AWS Fargate"},{"location":"docs/cicd/recipes/Service%20on%20Amazon%20Elastic%20Container%20Service%20%28ECS%29%20using%20AWS%20Fargate/","text":"Recipe ID: ConsoleAppEcsFargateService Recipe Description: This .NET Console application will be built using a Dockerfile and deployed as a service to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy a service as a container image on Linux. Settings: ECS Cluster ID: ECSCluster Description: The ECS cluster used for the deployment. Type: Object Settings: Create New ECS Cluster ID: CreateNew Description: Do you want to create a new ECS cluster? Type: Bool Existing Cluster ARN ID: ClusterArn Description: The ARN of the existing cluster to use. Type: String New Cluster Name ID: NewClusterName Description: The name of the new cluster to create. Type: String ECS Service Name ID: ECSServiceName Description: The name of the ECS service running in the cluster. Type: String Desired Task Count ID: DesiredCount Description: The desired number of ECS tasks to run for the service. Type: Int Application IAM Role ID: ApplicationIAMRole Description: The Identity and Access Management (IAM) role that provides AWS credentials to the application to access AWS services. Type: Object Settings: Create New Role ID: CreateNew Description: Do you want to create a new role? Type: Bool Existing Role ARN ID: RoleArn Description: The ARN of the existing role to use. Type: String Virtual Private Cloud (VPC) ID: Vpc Description: A VPC enables you to launch the application into a virtual network that you've defined. Type: Object Settings: Use default VPC ID: IsDefault Description: Do you want to use the default VPC for the deployment? Type: Bool Create New VPC ID: CreateNew Description: Do you want to create a new VPC? Type: Bool Existing VPC ID ID: VpcId Description: The ID of the existing VPC to use. Type: String ECS Service Security Groups ID: ECSServiceSecurityGroups Description: A comma-delimited list of EC2 security groups to assign to the ECS service. This is commonly used to provide access to Amazon RDS databases running in their own security groups. Type: String Task CPU ID: TaskCpu Description: The number of CPU units used by the task. See the following for details on CPU values: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html#fargate-task-defs Type: Int Task Memory ID: TaskMemory Description: The amount of memory (in MB) used by the task. See the following for details on memory values: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html#fargate-task-defs Type: Int AutoScaling ID: AutoScaling Description: The AutoScaling configuration for the ECS service. Type: Object Settings: Enable ID: Enabled Description: Do you want to enable AutoScaling? Type: Bool Minimum Capacity ID: MinCapacity Description: The minimum number of ECS tasks handling the demand for the ECS service. Type: Int Maximum Capacity ID: MaxCapacity Description: The maximum number of ECS tasks handling the demand for the ECS service. Type: Int AutoScaling Metric ID: ScalingType Description: The metric to monitor for scaling changes. Type: String CPU Target Utilization ID: CpuTypeTargetUtilizationPercent Description: The target cpu utilization percentage that triggers a scaling change. Type: Double Scale in cooldown (seconds) ID: CpuTypeScaleInCooldownSeconds Description: The amount of time, in seconds, after a scale in activity completes before another scale in activity can start. Type: Int Scale out cooldown (seconds) ID: CpuTypeScaleOutCooldownSeconds Description: The amount of time, in seconds, after a scale out activity completes before another scale out activity can start. Type: Int Memory Target Utilization ID: MemoryTypeTargetUtilizationPercent Description: The target memory utilization percentage that triggers a scaling change. Type: Double Scale in cooldown (seconds) ID: MemoryTypeScaleInCooldownSeconds Description: The amount of time, in seconds, after a scale in activity completes before another scale in activity can start. Type: Int Scale out cooldown (seconds) ID: MemoryTypeScaleOutCooldownSeconds Description: The amount of time, in seconds, after a scale out activity completes before another scale out activity can start. Type: Int Environment Variables ID: ECSEnvironmentVariables Description: Configure environment properties for your application. Type: KeyValue Environment Architecture ID: EnvironmentArchitecture Description: The CPU architecture of the environment to create. Type: String Docker Build Args ID: DockerBuildArgs Description: The list of additional options to append to the docker build command. Type: String Dockerfile Path ID: DockerfilePath Description: Specify a path to a Dockerfile as either an absolute path or a path relative to the project. Type: String Docker Execution Directory ID: DockerExecutionDirectory Description: Specifies the docker execution directory where the docker build command will be executed from. Type: String ECR Repository Name ID: ECRRepositoryName Description: Specifies the ECR repository where the Docker images will be stored Type: String","title":"Service on Amazon Elastic Container Service (ECS) using AWS Fargate"},{"location":"docs/commands/delete/","text":"delete-deployment command Usage dotnet aws delete-deployment - Tears down the application stack. Synopsis dotnet aws delete-deployment <APPLICATION-NAME> [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [-?|-h|--help] Description Tears down the application stack. Examples dotnet aws delete-deployment MY_APPLICATION --region us-west-2","title":"delete-deployment command"},{"location":"docs/commands/delete/#delete-deployment-command","text":"","title":"delete-deployment command"},{"location":"docs/commands/delete/#usage","text":"dotnet aws delete-deployment - Tears down the application stack.","title":"Usage"},{"location":"docs/commands/delete/#synopsis","text":"dotnet aws delete-deployment <APPLICATION-NAME> [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [-?|-h|--help]","title":"Synopsis"},{"location":"docs/commands/delete/#description","text":"Tears down the application stack.","title":"Description"},{"location":"docs/commands/delete/#examples","text":"dotnet aws delete-deployment MY_APPLICATION --region us-west-2","title":"Examples"},{"location":"docs/commands/deploy/","text":"deploy command Usage dotnet aws deploy - Inspect, build, and deploy the .NET project to AWS using the chosen AWS compute. Synopsis dotnet aws deploy [-d|\u2014-diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [--project-path <PROJECT-PATH>] [[--save-settings|--save-all-settings] <SETTINGS-FILE-PATH>] [--application-name <CLOUD-APPLICATION-NAME>] [--apply <PATH-TO-DEPLOYMENT-SETTINGS>] [--deployment-project <CDK-DEPLOYMENT-PROJECT-PATH>] [-?|-h|--help] Description Inspects the project and recommends AWS compute that is most suited to the type of deployed application. Then builds the project, generates a deployment CDK project to provision the required infrastructure, and deploys the .NET project to AWS using the chosen AWS compute. Examples Deploying HelloWorld dotnet new web -n HelloWorld -f net6.0 cd HelloWorld dotnet aws deploy Deploying application to a non-default profile dotnet aws deploy --profile myCustomProfile --region us-east1","title":"deploy command"},{"location":"docs/commands/deploy/#deploy-command","text":"","title":"deploy command"},{"location":"docs/commands/deploy/#usage","text":"dotnet aws deploy - Inspect, build, and deploy the .NET project to AWS using the chosen AWS compute.","title":"Usage"},{"location":"docs/commands/deploy/#synopsis","text":"dotnet aws deploy [-d|\u2014-diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [--project-path <PROJECT-PATH>] [[--save-settings|--save-all-settings] <SETTINGS-FILE-PATH>] [--application-name <CLOUD-APPLICATION-NAME>] [--apply <PATH-TO-DEPLOYMENT-SETTINGS>] [--deployment-project <CDK-DEPLOYMENT-PROJECT-PATH>] [-?|-h|--help]","title":"Synopsis"},{"location":"docs/commands/deploy/#description","text":"Inspects the project and recommends AWS compute that is most suited to the type of deployed application. Then builds the project, generates a deployment CDK project to provision the required infrastructure, and deploys the .NET project to AWS using the chosen AWS compute.","title":"Description"},{"location":"docs/commands/deploy/#examples","text":"Deploying HelloWorld dotnet new web -n HelloWorld -f net6.0 cd HelloWorld dotnet aws deploy Deploying application to a non-default profile dotnet aws deploy --profile myCustomProfile --region us-east1","title":"Examples"},{"location":"docs/commands/list/","text":"list-deployments command Usage dotnet aws list-deployments - Lists available cloud applications that were deployed using AWS Deploy Tool Synopsis dotnet new list-deployments [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [-?|-h|--help] Description Lists available cloud applications that were deployed using AWS Deploy Tool. Examples dotnet aws list-deployments --region us-west-2","title":"list-deployments command"},{"location":"docs/commands/list/#list-deployments-command","text":"","title":"list-deployments command"},{"location":"docs/commands/list/#usage","text":"dotnet aws list-deployments - Lists available cloud applications that were deployed using AWS Deploy Tool","title":"Usage"},{"location":"docs/commands/list/#synopsis","text":"dotnet new list-deployments [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [-?|-h|--help]","title":"Synopsis"},{"location":"docs/commands/list/#description","text":"Lists available cloud applications that were deployed using AWS Deploy Tool.","title":"Description"},{"location":"docs/commands/list/#examples","text":"dotnet aws list-deployments --region us-west-2","title":"Examples"},{"location":"docs/commands/project/","text":"deployment-project generate command Usage dotnet aws deployment-project - Generates and saves the deployment CDK project in the user provided location. Synopsis dotnet aws deployment-project generate [-o|--output <OUTPUT-PATH>] [-d|--diagnostics] [--project-path <PROJECT-PATH>] [--project-display-name <DISPLAY-NAME>] Description Generates and saves the deployment CDK project in a user-provided directory without proceeding with a deployment. This allows the user to customize the CDK project before deploying the application. The --output switch sets the directory where the CDK deployment project will be saved. The --project-path switch sets the path to the project to generate a deployment project for. The --project-display-name switch sets the name of the deployment project that will be displayed in the list of available deployment options. Examples This example creates a deployment project from the .NET project in the current directory. The deployment project will be saved to a sibling directory called CustomDeploymentProject. The name \"Team custom deployment project\" will be displayed in the list of the available deployment options. dotnet aws deployment-project generate --output ../CustomDeploymentProject --project-display-name \"Team custom deployment project\"","title":"deployment-project generate command"},{"location":"docs/commands/project/#deployment-project-generate-command","text":"","title":"deployment-project generate command"},{"location":"docs/commands/project/#usage","text":"dotnet aws deployment-project - Generates and saves the deployment CDK project in the user provided location.","title":"Usage"},{"location":"docs/commands/project/#synopsis","text":"dotnet aws deployment-project generate [-o|--output <OUTPUT-PATH>] [-d|--diagnostics] [--project-path <PROJECT-PATH>] [--project-display-name <DISPLAY-NAME>]","title":"Synopsis"},{"location":"docs/commands/project/#description","text":"Generates and saves the deployment CDK project in a user-provided directory without proceeding with a deployment. This allows the user to customize the CDK project before deploying the application. The --output switch sets the directory where the CDK deployment project will be saved. The --project-path switch sets the path to the project to generate a deployment project for. The --project-display-name switch sets the name of the deployment project that will be displayed in the list of available deployment options.","title":"Description"},{"location":"docs/commands/project/#examples","text":"This example creates a deployment project from the .NET project in the current directory. The deployment project will be saved to a sibling directory called CustomDeploymentProject. The name \"Team custom deployment project\" will be displayed in the list of the available deployment options. dotnet aws deployment-project generate --output ../CustomDeploymentProject --project-display-name \"Team custom deployment project\"","title":"Examples"},{"location":"docs/commands/server-mode/","text":"server-mode command Usage dotnet aws server-mode - Launches the tool in a server mode for integrations with IDE, for example Visual Studio. Synopsis dotnet aws server-mode [-d|--diagnostics] [-s|--silent] [-?|-h|--help] [--port <PORT>] [--parent-pid <PARENT-PID>] [--unsecure-mode] Description Starts the tool in the server mode to provide integration with IDEs, for example Visual Studio. This tool is not intended for end user usage unless you are writing a custom integration into an IDE. Examples dotnet aws server-mode --port 1234 --parent-pid 12345","title":"server-mode command"},{"location":"docs/commands/server-mode/#server-mode-command","text":"","title":"server-mode command"},{"location":"docs/commands/server-mode/#usage","text":"dotnet aws server-mode - Launches the tool in a server mode for integrations with IDE, for example Visual Studio.","title":"Usage"},{"location":"docs/commands/server-mode/#synopsis","text":"dotnet aws server-mode [-d|--diagnostics] [-s|--silent] [-?|-h|--help] [--port <PORT>] [--parent-pid <PARENT-PID>] [--unsecure-mode]","title":"Synopsis"},{"location":"docs/commands/server-mode/#description","text":"Starts the tool in the server mode to provide integration with IDEs, for example Visual Studio. This tool is not intended for end user usage unless you are writing a custom integration into an IDE.","title":"Description"},{"location":"docs/commands/server-mode/#examples","text":"dotnet aws server-mode --port 1234 --parent-pid 12345","title":"Examples"},{"location":"docs/deployment-projects/","text":"Deployment Projects What is a deployment recipe? The tool provides intelligent deployment recommendations that are tailored to your specific .NET application. The recommendation rules are defined in the deployment recipes . These recipes let you configure a pre-defined set of AWS resources related to your application such as IAM roles, virtual private clouds, load balancers, and more. There is a built-in recipe for each supported project type . All recipe definitions are available on GitHub . What is a deployment project? What if your application uses additional AWS resources that are not included in the built-in recipe, such as Amazon DynamoDB tables or Amazon SQS queues? In this case, you can extend one of the existing recipes and create a custom deployment project to manage additional AWS resources and services. Once you create and customize your deployment project, it will be displayed alongside the built-in recipes as a custom deployment option. ** Before:** The recommended deployment target is a built-in recipe for ASP.NET Core applications. ** After:** The recommended deployment target is a custom deployment project that manages a DynamoDB table in addition to the ASP.NET Core project. Parts of a deployment project A deployment project consists of two parts. For details, refer to the full reference guides below. Recipe file - a JSON configuration file that drives the deployment experience. .NET CDK project - a C# project that uses the AWS Cloud Development Kit (CDK) to define the infrastructure that will be created. Creating a deployment project To create a custom deployment project, run this command in the directory of the .NET project you wish to deploy. See deployment-project command for more details. dotnet aws deployment-project generate --output <output-directory> --project-display-name <display-name> The list of built-in recipes that are compatible with your .NET project will be displayed. Select the recipe that you want to customize, and a deployment project will be created in the --output directory. Note: It is important to add your deployment projects to source control. If your deployment project has been deleted, you will not be able to re-deploy your application to the same CloudFormation stack. Now you can begin customizing the deployment project. See our step-by-step tutorial for instructions. Searching for deployment projects When you run the dotnet aws deploy command, the tool searches for deployment projects anywhere underneath the solution (.sln) directory of project you are deploying. It also ensures that each deployment project is compatible with the .NET project being deployed. To point to a deployment project that is outside the solution directory, use the --deployment-project switch to pass in the path of the deployment project to use. This is common when sharing deployment projects across multiple solutions.","title":"Deployment Projects"},{"location":"docs/deployment-projects/#deployment-projects","text":"","title":"Deployment Projects"},{"location":"docs/deployment-projects/#what-is-a-deployment-recipe","text":"The tool provides intelligent deployment recommendations that are tailored to your specific .NET application. The recommendation rules are defined in the deployment recipes . These recipes let you configure a pre-defined set of AWS resources related to your application such as IAM roles, virtual private clouds, load balancers, and more. There is a built-in recipe for each supported project type . All recipe definitions are available on GitHub .","title":"What is a deployment recipe?"},{"location":"docs/deployment-projects/#what-is-a-deployment-project","text":"What if your application uses additional AWS resources that are not included in the built-in recipe, such as Amazon DynamoDB tables or Amazon SQS queues? In this case, you can extend one of the existing recipes and create a custom deployment project to manage additional AWS resources and services. Once you create and customize your deployment project, it will be displayed alongside the built-in recipes as a custom deployment option. ** Before:** The recommended deployment target is a built-in recipe for ASP.NET Core applications. ** After:** The recommended deployment target is a custom deployment project that manages a DynamoDB table in addition to the ASP.NET Core project.","title":"What is a deployment project?"},{"location":"docs/deployment-projects/#parts-of-a-deployment-project","text":"A deployment project consists of two parts. For details, refer to the full reference guides below. Recipe file - a JSON configuration file that drives the deployment experience. .NET CDK project - a C# project that uses the AWS Cloud Development Kit (CDK) to define the infrastructure that will be created.","title":"Parts of a deployment project"},{"location":"docs/deployment-projects/#creating-a-deployment-project","text":"To create a custom deployment project, run this command in the directory of the .NET project you wish to deploy. See deployment-project command for more details. dotnet aws deployment-project generate --output <output-directory> --project-display-name <display-name> The list of built-in recipes that are compatible with your .NET project will be displayed. Select the recipe that you want to customize, and a deployment project will be created in the --output directory. Note: It is important to add your deployment projects to source control. If your deployment project has been deleted, you will not be able to re-deploy your application to the same CloudFormation stack. Now you can begin customizing the deployment project. See our step-by-step tutorial for instructions.","title":"Creating a deployment project"},{"location":"docs/deployment-projects/#searching-for-deployment-projects","text":"When you run the dotnet aws deploy command, the tool searches for deployment projects anywhere underneath the solution (.sln) directory of project you are deploying. It also ensures that each deployment project is compatible with the .NET project being deployed. To point to a deployment project that is outside the solution directory, use the --deployment-project switch to pass in the path of the deployment project to use. This is common when sharing deployment projects across multiple solutions.","title":"Searching for deployment projects"},{"location":"docs/deployment-projects/cdk-project/","text":"CDK Project Each deployment project has a C# Cloud Development Kit (CDK) project. This CDK project is used to create the AWS infrastructure as a CloudFormation stack based on the user settings and to deploy your project to that infrastructure. Read our tutorial to see how you can customize this CDK project to add additional infrastructure resources for your deployments. What is AWS CDK? The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define your cloud application resources using familiar programming languages. The following links are useful resources to learn more about AWS CDK and how to write .NET CDK projects. AWS CDK Developer Guide .NET CDK Workshop .NET CDK Reference Layout of a CDK deployment project The layout of the generated CDK project puts all the code that was used to create the AWS resources defined in the starting recipe in a directory called Generated . It is recommended to not modify the code in the Generated directory to make it easier to merge future changes from the starting recipe into your custom deployment project. If you do not intend to update your custom deployment project from the original built-in recipe you may modify the code or rearrange the directory layout. If you choose to not modify the Generated code it is recommended to customize the CDK project starting from the AppStack class. Here is the constructor of AppStack . internal AppStack(Construct scope, IDeployToolStackProps<Configuration> props) : base(scope, props.StackName, props) { _configuration = props.RecipeProps.Settings; // Setup callback for generated construct to provide access to customize CDK properties before creating constructs. CDKRecipeCustomizer<Recipe>.CustomizeCDKProps += CustomizeCDKProps; // Create custom CDK constructs here that might need to be referenced in the CustomizeCDKProps. For example if // creating a DynamoDB table construct and then later using the CDK construct reference in CustomizeCDKProps to // pass the table name as an environment variable to the container image. // Create the recipe defined CDK construct with all of its sub constructs. var generatedRecipe = new Recipe(this, props.RecipeProps); // Create additional CDK constructs here. The recipe's constructs can be accessed as properties on // the generatedRecipe variable. } The var generatedRecipe = new Recipe(this, props.RecipeProps); statement creates all of the AWS resources specified in the CDK code in the Generated directory. Your customizations can create additional custom AWS resources from CDK constructs either before or after this statement. If you have custom resources you want to connect to resources generated by the recipe, create your custom resource before the statement. For example, you might want to set an environment variable in a container definition to the name of a custom DynamoDB table. In that scenario, your custom table should be created before the statement. However, if you want to connect a custom resource to a resource created by the recipe, create the custom resource after the statement. An example might be connecting a custom Amazon CloudFront distribution to an Application Load Balancer created in a recipe. Custom resources that have no connection to the resources created by the recipe can be added before, or after, the statement. In this constructor a callback method called CustomizeCDKProps is setup. This callback method is called right before any constructs are created from the Recipe . This allows modifying the construct's property object before it is passed into the construct. The example below shows the CustomizeCDKProps callback that checks to see if the resource being created is the Beanstalk Environment. If it is, cast the property object to the appropriate property object and then make whatever customizations are needed. private void CustomizeCDKProps(CustomizePropsEventArgs<Recipe> evnt) { if (string.Equals(evnt.ResourceLogicalName, nameof(evnt.Construct.BeanstalkEnvironment))) { if (evnt.Props is CfnEnvironmentProps props) { Console.WriteLine(\"Customizing Beanstalk Environment\"); } } } Main method in Program.cs The Main method in Program.cs for the CDK deployment project must be coded in a certain style to ensure compatibility with the deploy tool. The AWS Deploy Tool relies on .NET's Configuration system to pass along settings from the deploy tool to the CDK project. In the example below the ConfigurationBuilder().AddAWSDeployToolConfiguration(app) method reads the settings that were passed into the project from the deploy tool. With the configuration read from the deploy tool, the CDK environment is set to the account and region the deploy tool was configured with. The other major difference from normal CDK projects is the call to CDKRecipeSetup.RegisterStack . This is required to stamp the CloudFormation stack with the recipe id that created the stack. Future redeployments can only update existing stacks that were created by the original recipe. It also serializes the settings collected from the deploy tool into the metadata for the CloudFormation stack so redeployments can use the previous settings used for deployment. public static void Main(string[] args) { var app = new App(); var builder = new ConfigurationBuilder().AddAWSDeployToolConfiguration(app); var recipeProps = builder.Build().Get<RecipeProps<Configuration>>(); var appStackProps = new DeployToolStackProps<Configuration>(recipeProps) { Env = new Environment { Account = recipeProps.AWSAccountId, Region = recipeProps.AWSRegion } }; // The RegisterStack method is used to set identifying information on the stack // for the recipe used to deploy the application and preserve the settings used in the recipe // to allow redeployment. The information is stored as CloudFormation tags and metadata inside // the generated CloudFormation template. CDKRecipeSetup.RegisterStack<Configuration>(new AppStack(app, appStackProps), appStackProps.RecipeProps); app.Synth(); } Configuration options The option settings that are defined in the recipe file are passed into the CDK project and then deserialized into the Configuration object. When you add new settings to the recipe file, you also need to add the Id of the new settings to the Configuration object. If you added an Object setting with a collection of child settings, first create a new type representing that entire Object . For reach child setting id, add a property on the new type. Finally, add a new property on Configuration for your new type with the property name being the id of the Object setting. The Configuration object follows the same Generated directory pattern described above. Custom settings should be added to the partial Configuration.cs file outside of the Generated directory.","title":"CDK Project"},{"location":"docs/deployment-projects/cdk-project/#cdk-project","text":"Each deployment project has a C# Cloud Development Kit (CDK) project. This CDK project is used to create the AWS infrastructure as a CloudFormation stack based on the user settings and to deploy your project to that infrastructure. Read our tutorial to see how you can customize this CDK project to add additional infrastructure resources for your deployments.","title":"CDK Project"},{"location":"docs/deployment-projects/cdk-project/#what-is-aws-cdk","text":"The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define your cloud application resources using familiar programming languages. The following links are useful resources to learn more about AWS CDK and how to write .NET CDK projects. AWS CDK Developer Guide .NET CDK Workshop .NET CDK Reference","title":"What is AWS CDK?"},{"location":"docs/deployment-projects/cdk-project/#layout-of-a-cdk-deployment-project","text":"The layout of the generated CDK project puts all the code that was used to create the AWS resources defined in the starting recipe in a directory called Generated . It is recommended to not modify the code in the Generated directory to make it easier to merge future changes from the starting recipe into your custom deployment project. If you do not intend to update your custom deployment project from the original built-in recipe you may modify the code or rearrange the directory layout. If you choose to not modify the Generated code it is recommended to customize the CDK project starting from the AppStack class. Here is the constructor of AppStack . internal AppStack(Construct scope, IDeployToolStackProps<Configuration> props) : base(scope, props.StackName, props) { _configuration = props.RecipeProps.Settings; // Setup callback for generated construct to provide access to customize CDK properties before creating constructs. CDKRecipeCustomizer<Recipe>.CustomizeCDKProps += CustomizeCDKProps; // Create custom CDK constructs here that might need to be referenced in the CustomizeCDKProps. For example if // creating a DynamoDB table construct and then later using the CDK construct reference in CustomizeCDKProps to // pass the table name as an environment variable to the container image. // Create the recipe defined CDK construct with all of its sub constructs. var generatedRecipe = new Recipe(this, props.RecipeProps); // Create additional CDK constructs here. The recipe's constructs can be accessed as properties on // the generatedRecipe variable. } The var generatedRecipe = new Recipe(this, props.RecipeProps); statement creates all of the AWS resources specified in the CDK code in the Generated directory. Your customizations can create additional custom AWS resources from CDK constructs either before or after this statement. If you have custom resources you want to connect to resources generated by the recipe, create your custom resource before the statement. For example, you might want to set an environment variable in a container definition to the name of a custom DynamoDB table. In that scenario, your custom table should be created before the statement. However, if you want to connect a custom resource to a resource created by the recipe, create the custom resource after the statement. An example might be connecting a custom Amazon CloudFront distribution to an Application Load Balancer created in a recipe. Custom resources that have no connection to the resources created by the recipe can be added before, or after, the statement. In this constructor a callback method called CustomizeCDKProps is setup. This callback method is called right before any constructs are created from the Recipe . This allows modifying the construct's property object before it is passed into the construct. The example below shows the CustomizeCDKProps callback that checks to see if the resource being created is the Beanstalk Environment. If it is, cast the property object to the appropriate property object and then make whatever customizations are needed. private void CustomizeCDKProps(CustomizePropsEventArgs<Recipe> evnt) { if (string.Equals(evnt.ResourceLogicalName, nameof(evnt.Construct.BeanstalkEnvironment))) { if (evnt.Props is CfnEnvironmentProps props) { Console.WriteLine(\"Customizing Beanstalk Environment\"); } } }","title":"Layout of a CDK deployment project"},{"location":"docs/deployment-projects/cdk-project/#main-method-in-programcs","text":"The Main method in Program.cs for the CDK deployment project must be coded in a certain style to ensure compatibility with the deploy tool. The AWS Deploy Tool relies on .NET's Configuration system to pass along settings from the deploy tool to the CDK project. In the example below the ConfigurationBuilder().AddAWSDeployToolConfiguration(app) method reads the settings that were passed into the project from the deploy tool. With the configuration read from the deploy tool, the CDK environment is set to the account and region the deploy tool was configured with. The other major difference from normal CDK projects is the call to CDKRecipeSetup.RegisterStack . This is required to stamp the CloudFormation stack with the recipe id that created the stack. Future redeployments can only update existing stacks that were created by the original recipe. It also serializes the settings collected from the deploy tool into the metadata for the CloudFormation stack so redeployments can use the previous settings used for deployment. public static void Main(string[] args) { var app = new App(); var builder = new ConfigurationBuilder().AddAWSDeployToolConfiguration(app); var recipeProps = builder.Build().Get<RecipeProps<Configuration>>(); var appStackProps = new DeployToolStackProps<Configuration>(recipeProps) { Env = new Environment { Account = recipeProps.AWSAccountId, Region = recipeProps.AWSRegion } }; // The RegisterStack method is used to set identifying information on the stack // for the recipe used to deploy the application and preserve the settings used in the recipe // to allow redeployment. The information is stored as CloudFormation tags and metadata inside // the generated CloudFormation template. CDKRecipeSetup.RegisterStack<Configuration>(new AppStack(app, appStackProps), appStackProps.RecipeProps); app.Synth(); }","title":"Main method in Program.cs"},{"location":"docs/deployment-projects/cdk-project/#configuration-options","text":"The option settings that are defined in the recipe file are passed into the CDK project and then deserialized into the Configuration object. When you add new settings to the recipe file, you also need to add the Id of the new settings to the Configuration object. If you added an Object setting with a collection of child settings, first create a new type representing that entire Object . For reach child setting id, add a property on the new type. Finally, add a new property on Configuration for your new type with the property name being the id of the Object setting. The Configuration object follows the same Generated directory pattern described above. Custom settings should be added to the partial Configuration.cs file outside of the Generated directory.","title":"Configuration options"},{"location":"docs/deployment-projects/recipe-file/","text":"Recipe file schema Each deployment project has a JSON file with a .recipe extension. This recipe file defines the type of .NET projects the recipe is compatible with and the settings that will be shown to users. Read our tutorial to see how you can modify this file to drive the custom deployment experience and display custom option settings to users. The full schema for the recipe file can be found here . Top level settings This is the list of top level properties in the recipe definition. Id - the Id of the deployment project. The CloudFormation stack will be tagged with this Id which is used to identify which stacks to update when redeploying. Name - the name of the deployment project, shown in the list of recommendations. ShortDescription - description used when showing the list of recommendations. Description - longer description shown when hovering over the recommendation in Visual Studio. TargetService - the main AWS service the application will be deployed to. Visual Studio uses this to provide visual indicators. DeploymentType - for deployment projects this value should always be CdkProject . DeploymentBundle - how the .NET project being deployed should be bundled. Allowed values are Container and DotnetPublishZipFile . DisplayedResources - the list of resources to display to users at the end of the deployment. RecipePriority - the priority of the recipe in the compatibility list. RecommendationRules - the list of rules to determine the recipe's compatibility with the project being deployed. Categories - the list of categories for the option settings. OptionSettings - the list of settings users can configure during deployment. Displayed Resources The DisplayedResources array contains a list of resources that the deployment tooling should display after deployment is complete. This is typically the primary resources for a deployment project like an AWS Elastic Beanstalk Environment or a Load Balancer that allows the user to quickly see their application deployed to AWS. Here is an example for a recipe that displays the endpoint of the Elastic Beanstalk environment after deployment. ... \"DisplayedResources\": [ { \"LogicalId\": \"RecipeBeanstalkEnvironment83CC12DE\", \"Description\": \"Application Endpoint\" } ], ... DisplayedResources objects have the following properties: LogicalId - the CloudFormation logical id of the AWS resource. The CDK will generate a unique hash as the suffix of the logical resource id. The easiest way to figure out the value to set here is to do an initial deployment of the deployment project and then look up the logical id in the CloudFormation console. Description - a description for the resource shown to users in the list of display resources. Compatibility Rules The recipe file defines a collection of rules that the deployment tool executes against the .NET project being deployed to determine if the recipe is compatible with the .NET project. A rule is made up of a list of tests to run and the effect to apply. Tests The deploy tool supports a collection of tests that can be run against the .NET project being deployed. Here is an example of a test that checks the version of .NET the project is targeting. ... { \"Type\": \"MSProperty\", \"Condition\": { \"PropertyName\": \"TargetFramework\", \"AllowedValues\": [ \"netcoreapp3.1\", \"net6.0\" ] } } ... The Type property determines the type of test to run. The Condition contains the data needed to evaluate the test, in this case the MSBuild property to check and the allowed values. Each type of test can have a different set of properties for the Condition . Available Tests Type Description Conditions properties MSProjectSdkAttribute Compares the Sdk attribute at the root element of the project file to a given value. Value - the expected value. For example Microsoft.NET.Sdk.Web for web projects. MSProperty Compares the property in a project file property group. PropertyName - the property to compare. AllowedValues - an array of possible values for the property. MSPropertyExists Test to see if a property in a property group exists. PropertyName - the property test for existence. FileExists Tests to see if a file exists. For example checking to see a Dockerfile exists. FileName - the file to test for existence. NuGetPackageReference Test to see if the project has a PackageReference to a NuGet package. NuGetPackageName - the NuGet package to test if it is being referenced. Effect A rules effect defines the behavior of the rule depending on if its test(s) pass or not. Effects can either mark the recipe as not included in the compatible list or adjust the priority for the recipe. Here is an example of a rule that checks if the project is a web project and targets .NET Core 3.1 or .NET 6. If both tests pass the effect's Pass property instructs the deployment tooling to include the recipe. If either one of the two tests fail the Fail effect is run, removing the recipe from the included compatible list. ... \"RecommendationRules\": [ { \"Tests\": [ { \"Type\": \"MSProjectSdkAttribute\", \"Condition\": { \"Value\": \"Microsoft.NET.Sdk.Web\" } }, { \"Type\": \"MSProperty\", \"Condition\": { \"PropertyName\": \"TargetFramework\", \"AllowedValues\": [ \"netcoreapp3.1\", \"net6.0\" ] } } ], \"Effect\": { \"Pass\": { \"Include\": true }, \"Fail\": { \"Include\": false } } } ] ... Here is another example that tests if a project contains a Dockerfile. If it does not, it reduces the priority of the recipe. ... \"RecommendationRules\": [ ... { \"Tests\": [ { \"Type\": \"FileExists\", \"Condition\": { \"FileName\": \"Dockerfile\" } } ], \"Effect\": { \"Fail\": { \"PriorityAdjustment\": -100, \"Include\": true } } }, ... ] ... A recipe is considered compatible if no rule ran an effect that set Include to false and if the priority is greater then 0. To simulate an \"or\" set of rules the starting priority in RecipePriority can be set to a negative value meaning it is not included by default. Then you can have a series of tests that adjust the priority to a positive amount. That way, if any test rule passes it can adjust the priority to a positive number. Setting Categories The Categories property is an array of objects that define the categories for the settings. The AWS Toolkit for Visual Studio uses this array to build the list of categories in the UI for fast navigation to a group of settings. A category is defined with the following properties: Id - the unique id within the recipe for the category. DisplayName - the name of the category displayed to users. Order - the order in the toolkit UI for the category. Categories are display in sorted descending order. Here is an example of defining a custom category that you could use to categorize additional settings added as application resources. ... { \"Id\": \"AppResources\", \"DisplayName\": \"Application Resources\", \"Order\": 15 } ... To assign a setting to a category, set the setting's Category property to the Id of a category. Only top level settings can be assigned a category. Any top level settings that are not assigned a category will be placed in the General category. Option Settings The settings that are shown to users and allow them to customize the deployment in either the CLI or Visual Studio are defined in the OptionSettings array. Settings have the following properties. Id - the id of the setting. Once projects are deployed with the recipe, this id should not change because the id is saved into the CloudFormation stack's template. Name - the name of the setting shown to users. Description - the informational text shown to users for the setting. Type - the data type of the setting. DefaultValue - the default value for the setting. TypeHint - a hint to the deployment tooling what the meaning of the setting's value is. Some examples are an Amazon DynamoDB table name or the name of an Amazon SNS topic. TypeHintData - additional information to pass into the type hint. AdvancedSetting - a boolean for whether this setting is an advanced use case. If true the setting might not be shown to users unless they request to see all settings. Updatable - a boolean that controls whether a setting can be modified during redeployment. It is recommended to set this to false for settings where deleting resources once they exist would make the application unavailable. AllowedValues - the list of possible values. ValueMapping - a mapping between values in the AllowedValues list to user friendly display names for each allowed value. ChildOptionSettings - if the Type property is set to Object this list contains a child option settings. DependsOn - a list of expressions to determine if this setting should be visible. Validators - a list of validators to run when values are set for the setting to ensure the value is valid. ParentSettingId - the id of a setting that represents the parent of this setting. For example a setting that allows picking EC2 subnets would set the ParentSettingId to the setting that defines the VPC to use for deployment. The type hint for the setting can use this field to filter the list of subnets that are valid for the selected VPC. Setting Data Types Settings can have the following data types: String Int Double Bool KeyValue List Object If the data type is set to Object the setting has child settings that are defined in the ChildOptionSettings array for the setting. TypeHint Type hints are used to control the user experience in the CLI or Visual Studio. For example if the TypeHint property is set to ExistingECSCluster the deployment tool knows this String data type setting should be set to the name of an existing ECS cluster and presents the list of existing clusters to the user. Some type hints require additional configuration which can specified in the TypeHintData property. For example if a setting has a type hint of ExistingIAMRole the tool should only show roles that can be assumed by the target service. Here is a example of configuring the ServicePrincipal for the type hint to filter the list of roles to pick from. ... { \"Id\": \"RoleArn\", \"Name\": \"Existing Role ARN\", \"Description\": \"The ARN of the existing role to use.\", \"Type\": \"String\", \"TypeHint\": \"ExistingIAMRole\", \"TypeHintData\": { \"ServicePrincipal\": \"ecs-tasks.amazonaws.com\" }, ... Here is the list of available type hints in the deployment tooling. Type Hint Type Hint Data Notes IAMRole ServicePrincipal - the service principal the role can be assumed by. Set at Object level that controls whether to create a new role or select an existing role. ExistingIAMRole ServicePrincipal - the service principal the role can be assumed by. Set at the String setting level for storing the existing IAM role ARN. ECSCluster Set at the Object setting level that controls whether to create or select an existing ECS cluster. ExistingECSCluster Set at the String setting level for storing the existing ECS Cluster Name. ECSService ECSTaskSchedule EC2KeyPair Vpc Set at the Object level that controls whether to create a new VPC or select an existing VPC. ExistingVpc Set at the String setting level for storing the existing VPC ID. AppRunnerService VPCConnector Set at the Object level for creating or selecting an App Runner VPC Connector. ExistingVpcConnector Set at the String setting level for storing the existing VPC Connector id. BeanstalkRollingUpdates ExistingSubnets ParentSettingId should be set to a setting for the VPC. ExistingSecurityGroups ParentSettingId should be set to a setting for the VPC. ExistingBeanstalkApplication ExistingApplicationLoadBalancer InstanceType WindowsInstanceType S3BucketName AllowNoValue - determines whether to allow no value to be set. DynamoDBTableName AllowNoValue - determines whether to allow no value to be set. SQSQueueUrl AllowNoValue - determines whether to allow no value to be set. SNSTopicArn AllowNoValue - determines whether to allow no value to be set. FilePath Filter - the filter that appears in the file dialog box. DefaultExtension - the default extension used if the user specifies a file name without an extension. Title - the title of the file dialog box. CheckFileExists - if true the deployment tooling ensures the file exists. AllowEmpty - controls whether an empty value is allowed. DotnetBeanstalkPlatformArn DotnetWindowsBeanstalkPlatformArn DotnetPublishSelfContainedBuild Used internally to validate build configuration. DotnetPublishBuildConfiguration Used internally to validate build configuration. DotnetPublishAdditionalBuildArguments Used internally to validate build configuration. DockerExecutionDirectory Used internally to validate build configuration. DockerBuildArgs Used internally to validate build configuration. DependsOn The DependsOn property is an array of conditions to determine if a setting should be visible based on the values for other setting(s). For example if a user selects the setting to create a new IAM role then the setting for selecting an existing IAM role should not be displayed. Each item in the DependsOn array has the following properties. Id - the id of the setting to compare. The id should be the full id including all parent object id settings. The format is . . Operation - the operation to run. Allowed values are NotEmpty and Equals . If operation is not set then the default is Equals . Value - the value to compare when the operation is Equals . Here is an example for a setting used for storing an existing IAM role to use. The value is displayed if the setting ApplicationIAMRole.CreateNew is set false . ... { \"Id\": \"RoleArn\", \"Name\": \"Existing Role ARN\", \"Description\": \"The ARN of the existing role to use.\", \"Type\": \"String\", \"TypeHint\": \"ExistingIAMRole\", \"TypeHintData\": { \"ServicePrincipal\": \"tasks.apprunner.amazonaws.com\" }, \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"ApplicationIAMRole.CreateNew\", \"Value\": false } ], ... } ... Validators Validators inform the user when a setting has an invalid value before starting the deployment. Each setting can have a list of validators specified in the Validators array. Validators can do simple checks like making sure string values are of a certain format, as well as make AWS service calls to make sure the value of an existing resource exists. Here is an example of a validator for a port setting that ensures the value is within the range 0 to 51200. ... { \"Id\": \"Port\", \"Name\": \"Container Port\", \"Category\": \"General\", \"Description\": \"The port the container is listening for requests on.\", \"Type\": \"Int\", \"DefaultValue\": 80, \"AdvancedSetting\": false, \"Updatable\": true, \"Validators\": [ { \"ValidatorType\": \"Range\", \"Configuration\": { \"Min\": 0, \"Max\": 51200 } } ] } ... The ValidatorType property determines the type of validator to run. The Configuration contains the data needed to evaluate the validator, in this case the min and max values. Each type of validator can have a different set of properties for the Configuration . Validator Type Description Configuration properties Range For numeric settings define the min and max values. Min - the min value. Max - the max value. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. Regex For string settings define a regular expression that the value must match. Regex - the regular expression to match against the value of the setting. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. Required A value is required for the setting. ValidationFailedMessage - the error message shown if the validator fails. DirectoryExists For string settings representing a directory. Validates the directory exists. DockerBuildArgs Ensures the value is valid for being passed to the docker build command. DotnetPublishArgs Ensures the value is valid for being passed to the dotnet publish command. ExistingResource Using the AWS Cloud Control API GetResource , ensure that the AWS resource exists. ResourceType - the AWS resource type to search for. For example AWS::ECS::Cluster for an ECS cluster. FileExists For string settings representing a file path. Validates the file exists. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. StringLength Validates the length of a string setting. MinLength - the min length for the string. MaxLength - the max length for the string. ValidationFailedMessage - the error message shown if the validator fails. InstanceType Validates the string value is a valid Linux EC2 instance type. WindowsInstanceType Validates the string value is a valid Windows EC2 instance type. SubnetsInVpc Validates the subnets are in the configured VPC. VpcId - the id of the setting that has the VPC configured for. ValidationFailedMessage - the error message shown if the validator fails. SecurityGroupsInVpc Validates the security group are in the configured VPC. VpcId - the id of the setting that contains the VPC configuration. ValidationFailedMessage - the error message shown if the validator fails. Uri Validates the value is a well-formed URI string. ValidationFailedMessage - the error message shown if the validator fails. Comparison Compares this setting with another setting. SettingId - the setting to compare to. Operation - the comparison operation. Allowed values are GreaterThan . VPCSubnetsInDifferentAZs Validates that the selected VPC must have at least two subnets in two different Availability Zones ValidationFailedMessage - the error message shown if the validator fails.","title":"Recipe file schema"},{"location":"docs/deployment-projects/recipe-file/#recipe-file-schema","text":"Each deployment project has a JSON file with a .recipe extension. This recipe file defines the type of .NET projects the recipe is compatible with and the settings that will be shown to users. Read our tutorial to see how you can modify this file to drive the custom deployment experience and display custom option settings to users. The full schema for the recipe file can be found here .","title":"Recipe file schema"},{"location":"docs/deployment-projects/recipe-file/#top-level-settings","text":"This is the list of top level properties in the recipe definition. Id - the Id of the deployment project. The CloudFormation stack will be tagged with this Id which is used to identify which stacks to update when redeploying. Name - the name of the deployment project, shown in the list of recommendations. ShortDescription - description used when showing the list of recommendations. Description - longer description shown when hovering over the recommendation in Visual Studio. TargetService - the main AWS service the application will be deployed to. Visual Studio uses this to provide visual indicators. DeploymentType - for deployment projects this value should always be CdkProject . DeploymentBundle - how the .NET project being deployed should be bundled. Allowed values are Container and DotnetPublishZipFile . DisplayedResources - the list of resources to display to users at the end of the deployment. RecipePriority - the priority of the recipe in the compatibility list. RecommendationRules - the list of rules to determine the recipe's compatibility with the project being deployed. Categories - the list of categories for the option settings. OptionSettings - the list of settings users can configure during deployment.","title":"Top level settings"},{"location":"docs/deployment-projects/recipe-file/#displayed-resources","text":"The DisplayedResources array contains a list of resources that the deployment tooling should display after deployment is complete. This is typically the primary resources for a deployment project like an AWS Elastic Beanstalk Environment or a Load Balancer that allows the user to quickly see their application deployed to AWS. Here is an example for a recipe that displays the endpoint of the Elastic Beanstalk environment after deployment. ... \"DisplayedResources\": [ { \"LogicalId\": \"RecipeBeanstalkEnvironment83CC12DE\", \"Description\": \"Application Endpoint\" } ], ... DisplayedResources objects have the following properties: LogicalId - the CloudFormation logical id of the AWS resource. The CDK will generate a unique hash as the suffix of the logical resource id. The easiest way to figure out the value to set here is to do an initial deployment of the deployment project and then look up the logical id in the CloudFormation console. Description - a description for the resource shown to users in the list of display resources.","title":"Displayed Resources"},{"location":"docs/deployment-projects/recipe-file/#compatibility-rules","text":"The recipe file defines a collection of rules that the deployment tool executes against the .NET project being deployed to determine if the recipe is compatible with the .NET project. A rule is made up of a list of tests to run and the effect to apply.","title":"Compatibility Rules"},{"location":"docs/deployment-projects/recipe-file/#tests","text":"The deploy tool supports a collection of tests that can be run against the .NET project being deployed. Here is an example of a test that checks the version of .NET the project is targeting. ... { \"Type\": \"MSProperty\", \"Condition\": { \"PropertyName\": \"TargetFramework\", \"AllowedValues\": [ \"netcoreapp3.1\", \"net6.0\" ] } } ... The Type property determines the type of test to run. The Condition contains the data needed to evaluate the test, in this case the MSBuild property to check and the allowed values. Each type of test can have a different set of properties for the Condition .","title":"Tests"},{"location":"docs/deployment-projects/recipe-file/#available-tests","text":"Type Description Conditions properties MSProjectSdkAttribute Compares the Sdk attribute at the root element of the project file to a given value. Value - the expected value. For example Microsoft.NET.Sdk.Web for web projects. MSProperty Compares the property in a project file property group. PropertyName - the property to compare. AllowedValues - an array of possible values for the property. MSPropertyExists Test to see if a property in a property group exists. PropertyName - the property test for existence. FileExists Tests to see if a file exists. For example checking to see a Dockerfile exists. FileName - the file to test for existence. NuGetPackageReference Test to see if the project has a PackageReference to a NuGet package. NuGetPackageName - the NuGet package to test if it is being referenced.","title":"Available Tests"},{"location":"docs/deployment-projects/recipe-file/#effect","text":"A rules effect defines the behavior of the rule depending on if its test(s) pass or not. Effects can either mark the recipe as not included in the compatible list or adjust the priority for the recipe. Here is an example of a rule that checks if the project is a web project and targets .NET Core 3.1 or .NET 6. If both tests pass the effect's Pass property instructs the deployment tooling to include the recipe. If either one of the two tests fail the Fail effect is run, removing the recipe from the included compatible list. ... \"RecommendationRules\": [ { \"Tests\": [ { \"Type\": \"MSProjectSdkAttribute\", \"Condition\": { \"Value\": \"Microsoft.NET.Sdk.Web\" } }, { \"Type\": \"MSProperty\", \"Condition\": { \"PropertyName\": \"TargetFramework\", \"AllowedValues\": [ \"netcoreapp3.1\", \"net6.0\" ] } } ], \"Effect\": { \"Pass\": { \"Include\": true }, \"Fail\": { \"Include\": false } } } ] ... Here is another example that tests if a project contains a Dockerfile. If it does not, it reduces the priority of the recipe. ... \"RecommendationRules\": [ ... { \"Tests\": [ { \"Type\": \"FileExists\", \"Condition\": { \"FileName\": \"Dockerfile\" } } ], \"Effect\": { \"Fail\": { \"PriorityAdjustment\": -100, \"Include\": true } } }, ... ] ... A recipe is considered compatible if no rule ran an effect that set Include to false and if the priority is greater then 0. To simulate an \"or\" set of rules the starting priority in RecipePriority can be set to a negative value meaning it is not included by default. Then you can have a series of tests that adjust the priority to a positive amount. That way, if any test rule passes it can adjust the priority to a positive number.","title":"Effect"},{"location":"docs/deployment-projects/recipe-file/#setting-categories","text":"The Categories property is an array of objects that define the categories for the settings. The AWS Toolkit for Visual Studio uses this array to build the list of categories in the UI for fast navigation to a group of settings. A category is defined with the following properties: Id - the unique id within the recipe for the category. DisplayName - the name of the category displayed to users. Order - the order in the toolkit UI for the category. Categories are display in sorted descending order. Here is an example of defining a custom category that you could use to categorize additional settings added as application resources. ... { \"Id\": \"AppResources\", \"DisplayName\": \"Application Resources\", \"Order\": 15 } ... To assign a setting to a category, set the setting's Category property to the Id of a category. Only top level settings can be assigned a category. Any top level settings that are not assigned a category will be placed in the General category.","title":"Setting Categories"},{"location":"docs/deployment-projects/recipe-file/#option-settings","text":"The settings that are shown to users and allow them to customize the deployment in either the CLI or Visual Studio are defined in the OptionSettings array. Settings have the following properties. Id - the id of the setting. Once projects are deployed with the recipe, this id should not change because the id is saved into the CloudFormation stack's template. Name - the name of the setting shown to users. Description - the informational text shown to users for the setting. Type - the data type of the setting. DefaultValue - the default value for the setting. TypeHint - a hint to the deployment tooling what the meaning of the setting's value is. Some examples are an Amazon DynamoDB table name or the name of an Amazon SNS topic. TypeHintData - additional information to pass into the type hint. AdvancedSetting - a boolean for whether this setting is an advanced use case. If true the setting might not be shown to users unless they request to see all settings. Updatable - a boolean that controls whether a setting can be modified during redeployment. It is recommended to set this to false for settings where deleting resources once they exist would make the application unavailable. AllowedValues - the list of possible values. ValueMapping - a mapping between values in the AllowedValues list to user friendly display names for each allowed value. ChildOptionSettings - if the Type property is set to Object this list contains a child option settings. DependsOn - a list of expressions to determine if this setting should be visible. Validators - a list of validators to run when values are set for the setting to ensure the value is valid. ParentSettingId - the id of a setting that represents the parent of this setting. For example a setting that allows picking EC2 subnets would set the ParentSettingId to the setting that defines the VPC to use for deployment. The type hint for the setting can use this field to filter the list of subnets that are valid for the selected VPC.","title":"Option Settings"},{"location":"docs/deployment-projects/recipe-file/#setting-data-types","text":"Settings can have the following data types: String Int Double Bool KeyValue List Object If the data type is set to Object the setting has child settings that are defined in the ChildOptionSettings array for the setting.","title":"Setting Data Types"},{"location":"docs/deployment-projects/recipe-file/#typehint","text":"Type hints are used to control the user experience in the CLI or Visual Studio. For example if the TypeHint property is set to ExistingECSCluster the deployment tool knows this String data type setting should be set to the name of an existing ECS cluster and presents the list of existing clusters to the user. Some type hints require additional configuration which can specified in the TypeHintData property. For example if a setting has a type hint of ExistingIAMRole the tool should only show roles that can be assumed by the target service. Here is a example of configuring the ServicePrincipal for the type hint to filter the list of roles to pick from. ... { \"Id\": \"RoleArn\", \"Name\": \"Existing Role ARN\", \"Description\": \"The ARN of the existing role to use.\", \"Type\": \"String\", \"TypeHint\": \"ExistingIAMRole\", \"TypeHintData\": { \"ServicePrincipal\": \"ecs-tasks.amazonaws.com\" }, ... Here is the list of available type hints in the deployment tooling. Type Hint Type Hint Data Notes IAMRole ServicePrincipal - the service principal the role can be assumed by. Set at Object level that controls whether to create a new role or select an existing role. ExistingIAMRole ServicePrincipal - the service principal the role can be assumed by. Set at the String setting level for storing the existing IAM role ARN. ECSCluster Set at the Object setting level that controls whether to create or select an existing ECS cluster. ExistingECSCluster Set at the String setting level for storing the existing ECS Cluster Name. ECSService ECSTaskSchedule EC2KeyPair Vpc Set at the Object level that controls whether to create a new VPC or select an existing VPC. ExistingVpc Set at the String setting level for storing the existing VPC ID. AppRunnerService VPCConnector Set at the Object level for creating or selecting an App Runner VPC Connector. ExistingVpcConnector Set at the String setting level for storing the existing VPC Connector id. BeanstalkRollingUpdates ExistingSubnets ParentSettingId should be set to a setting for the VPC. ExistingSecurityGroups ParentSettingId should be set to a setting for the VPC. ExistingBeanstalkApplication ExistingApplicationLoadBalancer InstanceType WindowsInstanceType S3BucketName AllowNoValue - determines whether to allow no value to be set. DynamoDBTableName AllowNoValue - determines whether to allow no value to be set. SQSQueueUrl AllowNoValue - determines whether to allow no value to be set. SNSTopicArn AllowNoValue - determines whether to allow no value to be set. FilePath Filter - the filter that appears in the file dialog box. DefaultExtension - the default extension used if the user specifies a file name without an extension. Title - the title of the file dialog box. CheckFileExists - if true the deployment tooling ensures the file exists. AllowEmpty - controls whether an empty value is allowed. DotnetBeanstalkPlatformArn DotnetWindowsBeanstalkPlatformArn DotnetPublishSelfContainedBuild Used internally to validate build configuration. DotnetPublishBuildConfiguration Used internally to validate build configuration. DotnetPublishAdditionalBuildArguments Used internally to validate build configuration. DockerExecutionDirectory Used internally to validate build configuration. DockerBuildArgs Used internally to validate build configuration.","title":"TypeHint"},{"location":"docs/deployment-projects/recipe-file/#dependson","text":"The DependsOn property is an array of conditions to determine if a setting should be visible based on the values for other setting(s). For example if a user selects the setting to create a new IAM role then the setting for selecting an existing IAM role should not be displayed. Each item in the DependsOn array has the following properties. Id - the id of the setting to compare. The id should be the full id including all parent object id settings. The format is . . Operation - the operation to run. Allowed values are NotEmpty and Equals . If operation is not set then the default is Equals . Value - the value to compare when the operation is Equals . Here is an example for a setting used for storing an existing IAM role to use. The value is displayed if the setting ApplicationIAMRole.CreateNew is set false . ... { \"Id\": \"RoleArn\", \"Name\": \"Existing Role ARN\", \"Description\": \"The ARN of the existing role to use.\", \"Type\": \"String\", \"TypeHint\": \"ExistingIAMRole\", \"TypeHintData\": { \"ServicePrincipal\": \"tasks.apprunner.amazonaws.com\" }, \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"ApplicationIAMRole.CreateNew\", \"Value\": false } ], ... } ...","title":"DependsOn"},{"location":"docs/deployment-projects/recipe-file/#validators","text":"Validators inform the user when a setting has an invalid value before starting the deployment. Each setting can have a list of validators specified in the Validators array. Validators can do simple checks like making sure string values are of a certain format, as well as make AWS service calls to make sure the value of an existing resource exists. Here is an example of a validator for a port setting that ensures the value is within the range 0 to 51200. ... { \"Id\": \"Port\", \"Name\": \"Container Port\", \"Category\": \"General\", \"Description\": \"The port the container is listening for requests on.\", \"Type\": \"Int\", \"DefaultValue\": 80, \"AdvancedSetting\": false, \"Updatable\": true, \"Validators\": [ { \"ValidatorType\": \"Range\", \"Configuration\": { \"Min\": 0, \"Max\": 51200 } } ] } ... The ValidatorType property determines the type of validator to run. The Configuration contains the data needed to evaluate the validator, in this case the min and max values. Each type of validator can have a different set of properties for the Configuration . Validator Type Description Configuration properties Range For numeric settings define the min and max values. Min - the min value. Max - the max value. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. Regex For string settings define a regular expression that the value must match. Regex - the regular expression to match against the value of the setting. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. Required A value is required for the setting. ValidationFailedMessage - the error message shown if the validator fails. DirectoryExists For string settings representing a directory. Validates the directory exists. DockerBuildArgs Ensures the value is valid for being passed to the docker build command. DotnetPublishArgs Ensures the value is valid for being passed to the dotnet publish command. ExistingResource Using the AWS Cloud Control API GetResource , ensure that the AWS resource exists. ResourceType - the AWS resource type to search for. For example AWS::ECS::Cluster for an ECS cluster. FileExists For string settings representing a file path. Validates the file exists. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. StringLength Validates the length of a string setting. MinLength - the min length for the string. MaxLength - the max length for the string. ValidationFailedMessage - the error message shown if the validator fails. InstanceType Validates the string value is a valid Linux EC2 instance type. WindowsInstanceType Validates the string value is a valid Windows EC2 instance type. SubnetsInVpc Validates the subnets are in the configured VPC. VpcId - the id of the setting that has the VPC configured for. ValidationFailedMessage - the error message shown if the validator fails. SecurityGroupsInVpc Validates the security group are in the configured VPC. VpcId - the id of the setting that contains the VPC configuration. ValidationFailedMessage - the error message shown if the validator fails. Uri Validates the value is a well-formed URI string. ValidationFailedMessage - the error message shown if the validator fails. Comparison Compares this setting with another setting. SettingId - the setting to compare to. Operation - the comparison operation. Allowed values are GreaterThan . VPCSubnetsInDifferentAZs Validates that the selected VPC must have at least two subnets in two different Availability Zones ValidationFailedMessage - the error message shown if the validator fails.","title":"Validators"},{"location":"docs/docker/docker-generation/","text":"Dockerfile Generation IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used for deployment. The Dockerfile the deployment tool generates uses Docker's multistage build process. This allows efficient and smaller container images that only contain the bits that are required to run your application. For a sample web application which has following directory structure: \u2503MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2517 WeatherForecast.cs \u2517 MyWebApplication.sln Build Build stage consists of copying the files from the host machine to the container, restoring the dependencies, and building the application. Deployment Tool uses the directory containing the solution file (*.sln) as build context and generates file paths relative to that directory. FROM mcr.microsoft.com/dotnet/core/aspnet:6.0 AS base WORKDIR /app EXPOSE 80 EXPOSE 443 WORKDIR /src COPY [\"MyWebApplication/MyWebApplication.csproj\", \"MyWebApplication/\"] COPY [\"MyClassLibrary/MyClassLibrary.csproj\", \"MyClassLibrary/\"] RUN dotnet restore \"MyWebApplication/MyWebApplication.csproj\" COPY . . WORKDIR \"/src/MyWebApplication\" RUN dotnet build \"MyWebApplication.csproj\" -c Release -o /app/build Publish Publish stage takes the build output and publishes the .NET application to /app/publish directory. FROM build AS publish RUN dotnet publish \"MyWebApplication.csproj\" -c Release -o /app/publish Final Final stage takes the publish output and copies it to the container which uses ASP.NET Core image as a base image. FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\"dotnet\", \"MyWebApplication.dll\"]","title":"Dockerfile Generation"},{"location":"docs/docker/docker-generation/#dockerfile-generation","text":"IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used for deployment. The Dockerfile the deployment tool generates uses Docker's multistage build process. This allows efficient and smaller container images that only contain the bits that are required to run your application. For a sample web application which has following directory structure: \u2503MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2517 WeatherForecast.cs \u2517 MyWebApplication.sln","title":"Dockerfile Generation"},{"location":"docs/docker/docker-generation/#build","text":"Build stage consists of copying the files from the host machine to the container, restoring the dependencies, and building the application. Deployment Tool uses the directory containing the solution file (*.sln) as build context and generates file paths relative to that directory. FROM mcr.microsoft.com/dotnet/core/aspnet:6.0 AS base WORKDIR /app EXPOSE 80 EXPOSE 443 WORKDIR /src COPY [\"MyWebApplication/MyWebApplication.csproj\", \"MyWebApplication/\"] COPY [\"MyClassLibrary/MyClassLibrary.csproj\", \"MyClassLibrary/\"] RUN dotnet restore \"MyWebApplication/MyWebApplication.csproj\" COPY . . WORKDIR \"/src/MyWebApplication\" RUN dotnet build \"MyWebApplication.csproj\" -c Release -o /app/build","title":"Build"},{"location":"docs/docker/docker-generation/#publish","text":"Publish stage takes the build output and publishes the .NET application to /app/publish directory. FROM build AS publish RUN dotnet publish \"MyWebApplication.csproj\" -c Release -o /app/publish","title":"Publish"},{"location":"docs/docker/docker-generation/#final","text":"Final stage takes the publish output and copies it to the container which uses ASP.NET Core image as a base image. FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\"dotnet\", \"MyWebApplication.dll\"]","title":"Final"},{"location":"docs/docker/publish-image/","text":"Pushing a Docker image to Amazon ECR repository If your application contains an existing Dockerfile, you can build and push your container images to an Amazon Elastic Container Registry (Amazon ECR) repository using \"Push Container Images to Amazon Elastic Container Registry\" deployment option. To learn more about Amazon ECR, including required IAM permissions for pushing an image, see Amazon ECR product page .","title":"Pushing a Docker image to Amazon ECR repository"},{"location":"docs/docker/publish-image/#pushing-a-docker-image-to-amazon-ecr-repository","text":"If your application contains an existing Dockerfile, you can build and push your container images to an Amazon Elastic Container Registry (Amazon ECR) repository using \"Push Container Images to Amazon Elastic Container Registry\" deployment option. To learn more about Amazon ECR, including required IAM permissions for pushing an image, see Amazon ECR product page .","title":"Pushing a Docker image to Amazon ECR repository"},{"location":"docs/getting-started/custom-workspace/","text":"Set up a custom workspace The default workspace used by AWS.Deploy.Tools is $USERPROFILE/.aws-dotnet-deploy on Windows and $USER/.aws-dotnet-deploy on Unix based OS. This workspace is used to create the CDK project and any other temporary files used by the tool. You can override the default workspace by the setting the AWS_DOTNET_DEPLOYTOOL_WORKSPACE environment variable. It must satisfy the following constraints: It must point to a valid directory that exists on the disk. The directory path must not have any whitespace characters in it. Setting up a custom workspace is optional for most users. However, on Windows OS, if the $USERPROFILE path contains a whitespace character then the deployment will fail. In that case, users are required to set up a custom workspace that satisfies the above constraints.","title":"Set up a custom workspace"},{"location":"docs/getting-started/custom-workspace/#set-up-a-custom-workspace","text":"The default workspace used by AWS.Deploy.Tools is $USERPROFILE/.aws-dotnet-deploy on Windows and $USER/.aws-dotnet-deploy on Unix based OS. This workspace is used to create the CDK project and any other temporary files used by the tool. You can override the default workspace by the setting the AWS_DOTNET_DEPLOYTOOL_WORKSPACE environment variable. It must satisfy the following constraints: It must point to a valid directory that exists on the disk. The directory path must not have any whitespace characters in it. Setting up a custom workspace is optional for most users. However, on Windows OS, if the $USERPROFILE path contains a whitespace character then the deployment will fail. In that case, users are required to set up a custom workspace that satisfies the above constraints.","title":"Set up a custom workspace"},{"location":"docs/getting-started/installation/","text":"Installing the deployment tool The following instructions show you how to install, update, and uninstall the deployment tool. Install To install the deployment tool, use the dotnet tool install command: dotnet tool install -g aws.deploy.tools Update To update to the latest version of the deployment tool, use the dotnet tool update command. dotnet tool update -g aws.deploy.tools Note The deployment tool was initially in a NuGet package called \"aws.deploy.cli\". If you have this older version of the tool, you'll see a deprecation notice and the version will be 0.40.18 or earlier. Uninstall the older version of the tool and install a new one. Uninstall To uninstall it, simply type: dotnet tool uninstall -g aws.deploy.tools Help Once you install the tool, you can view the list of available commands by typing: dotnet aws --help To get help about individual commands like deploy or delete-deployment you can use the --help switch with the commands. For example to get help for the deploy command type: dotnet aws deploy --help","title":"Installing the deployment tool"},{"location":"docs/getting-started/installation/#installing-the-deployment-tool","text":"The following instructions show you how to install, update, and uninstall the deployment tool.","title":"Installing the deployment tool"},{"location":"docs/getting-started/installation/#install","text":"To install the deployment tool, use the dotnet tool install command: dotnet tool install -g aws.deploy.tools","title":"Install"},{"location":"docs/getting-started/installation/#update","text":"To update to the latest version of the deployment tool, use the dotnet tool update command. dotnet tool update -g aws.deploy.tools Note The deployment tool was initially in a NuGet package called \"aws.deploy.cli\". If you have this older version of the tool, you'll see a deprecation notice and the version will be 0.40.18 or earlier. Uninstall the older version of the tool and install a new one.","title":"Update"},{"location":"docs/getting-started/installation/#uninstall","text":"To uninstall it, simply type: dotnet tool uninstall -g aws.deploy.tools","title":"Uninstall"},{"location":"docs/getting-started/installation/#help","text":"Once you install the tool, you can view the list of available commands by typing: dotnet aws --help To get help about individual commands like deploy or delete-deployment you can use the --help switch with the commands. For example to get help for the deploy command type: dotnet aws deploy --help","title":"Help"},{"location":"docs/getting-started/pre-requisites/","text":"Setting up your environment To run the AWS Deploy Tool, you need the following pre-requisites set up in your environment: AWS Account An AWS account with a local credential profile configured in the shared AWS config and credentials files. For information on setting up a profile, see our SDK Reference Guide . The local credential profile can be configured by a variety of tools. For example, the credential profile can be configured with the AWS Toolkit for Visual Studio or the AWS CLI , among others. Note: You need to make sure to add the appropriate AWS permissions to your credentials\u2019 profile / assumed role. See Setting up Credentials .NET 6 or later .NET CLI - the deployment tool can be used from the .NET command-line interface (CLI) - a cross-platform toolchain for developing, building, running, and publishing .NET applications. The .NET CLI is included with the .NET SDK . For information about how to install or update .NET, see https://dotnet.microsoft.com/ . The deployment tool requires .NET 6 or later to be installed. However, the deployment tool supports deploying applications built using .NET Core 3.1 or later (for example, .NET Core 3.1, .NET 5.0, .NET 6.0, .NET 7). To see what version you have, run the following on the command prompt or in a terminal: dotnet --version Node.js The deployment tool requires the AWS Cloud Development Kit (CDK) , and the AWS CDK requires Node.js . AWS CDK requires Node.js, versions 14.x, 16.x, 18.x (or later) - we recommend installing the latest LTS version. To install Node.js, go to Node.js downloads To see which version of Node.js you have installed, run the following command at the command prompt or in a terminal: node --version Note: If the AWS CDK isn't installed on your machine or if the AWS CDK that's installed is earlier than the required minimum version (2.13.0), the deployment tool will install a temporary and \"private\" copy of the CDK that will be used only by the tool, leaving the global configuration of your machine untouched. If instead you want to install the AWS CDK, see Install the AWS CDK in the AWS Cloud Development Kit (CDK) Developer Guide Docker (Optional) Docker - required when deploying to a container based service like Amazon Elastic Container Service (Amazon ECS) or AWS App Runner. To install Docker, go to https://docs.docker.com/engine/install/ . ZIP CLI (Linux and macOS) Mac / Linux only. Used when creating zip packages for deployment bundles. The zip cli is used to maintain Linux file permissions.","title":"Setting up your environment"},{"location":"docs/getting-started/pre-requisites/#setting-up-your-environment","text":"To run the AWS Deploy Tool, you need the following pre-requisites set up in your environment:","title":"Setting up your environment"},{"location":"docs/getting-started/pre-requisites/#aws-account","text":"An AWS account with a local credential profile configured in the shared AWS config and credentials files. For information on setting up a profile, see our SDK Reference Guide . The local credential profile can be configured by a variety of tools. For example, the credential profile can be configured with the AWS Toolkit for Visual Studio or the AWS CLI , among others. Note: You need to make sure to add the appropriate AWS permissions to your credentials\u2019 profile / assumed role. See Setting up Credentials","title":"AWS Account"},{"location":"docs/getting-started/pre-requisites/#net-6-or-later","text":".NET CLI - the deployment tool can be used from the .NET command-line interface (CLI) - a cross-platform toolchain for developing, building, running, and publishing .NET applications. The .NET CLI is included with the .NET SDK . For information about how to install or update .NET, see https://dotnet.microsoft.com/ . The deployment tool requires .NET 6 or later to be installed. However, the deployment tool supports deploying applications built using .NET Core 3.1 or later (for example, .NET Core 3.1, .NET 5.0, .NET 6.0, .NET 7). To see what version you have, run the following on the command prompt or in a terminal: dotnet --version","title":".NET 6 or later"},{"location":"docs/getting-started/pre-requisites/#nodejs","text":"The deployment tool requires the AWS Cloud Development Kit (CDK) , and the AWS CDK requires Node.js . AWS CDK requires Node.js, versions 14.x, 16.x, 18.x (or later) - we recommend installing the latest LTS version. To install Node.js, go to Node.js downloads To see which version of Node.js you have installed, run the following command at the command prompt or in a terminal: node --version Note: If the AWS CDK isn't installed on your machine or if the AWS CDK that's installed is earlier than the required minimum version (2.13.0), the deployment tool will install a temporary and \"private\" copy of the CDK that will be used only by the tool, leaving the global configuration of your machine untouched. If instead you want to install the AWS CDK, see Install the AWS CDK in the AWS Cloud Development Kit (CDK) Developer Guide","title":"Node.js"},{"location":"docs/getting-started/pre-requisites/#docker-optional","text":"Docker - required when deploying to a container based service like Amazon Elastic Container Service (Amazon ECS) or AWS App Runner. To install Docker, go to https://docs.docker.com/engine/install/ .","title":"Docker (Optional)"},{"location":"docs/getting-started/pre-requisites/#zip-cli-linux-and-macos","text":"Mac / Linux only. Used when creating zip packages for deployment bundles. The zip cli is used to maintain Linux file permissions.","title":"ZIP CLI (Linux and macOS)"},{"location":"docs/getting-started/run-tool/","text":"Deploying a sample application This article teaches you how to deploy a simple \u201cHello World!\" web application to AWS. Install the tool and its pre-requisites before running the steps below. The command for the deployment tool can be expressed in one of two forms. Either form might be used for command examples. dotnet aws ... dotnet-aws ... Step 1: Create the ASP.NET Web application dotnet new web -n HelloWorld -f net6.0 Step 2: cd to the project folder cd HelloWorld Step 3: Deploy to AWS dotnet aws deploy --profile default --region us-east-1","title":"Deploying a sample application"},{"location":"docs/getting-started/run-tool/#deploying-a-sample-application","text":"This article teaches you how to deploy a simple \u201cHello World!\" web application to AWS. Install the tool and its pre-requisites before running the steps below. The command for the deployment tool can be expressed in one of two forms. Either form might be used for command examples. dotnet aws ... dotnet-aws ...","title":"Deploying a sample application"},{"location":"docs/getting-started/run-tool/#step-1-create-the-aspnet-web-application","text":"dotnet new web -n HelloWorld -f net6.0","title":"Step 1: Create the ASP.NET Web application"},{"location":"docs/getting-started/run-tool/#step-2-cd-to-the-project-folder","text":"cd HelloWorld","title":"Step 2: cd to the project folder"},{"location":"docs/getting-started/run-tool/#step-3-deploy-to-aws","text":"dotnet aws deploy --profile default --region us-east-1","title":"Step 3: Deploy to AWS"},{"location":"docs/getting-started/setup-creds/","text":"Set up credentials The AWS Deploy Tool for .NET internally uses a variety of different tools and services to host your .NET application on AWS. To run the AWS Deploy Tool, you must configure a credential profile that provides access to the AWS account you wish to deploy to. Your credentials must have permissions for certain services, depending on the tasks that you're trying to perform. Recommended policies The AWS Deploy Tool for .NET uses AWS Cloud Development Kit (CDK) to create the AWS infrastructure needed to deploy your application. Deploying via AWS CDK will assume roles that were created when bootstrapping CDK for the account and region you are deploying into. Ensure that the profile you are deploying with has permission to assume the CDK deployment roles. This can be done with a policy such as: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"sts:AssumeRole\" ], \"Resource\": [ \"arn:aws:iam::*:role/cdk-*\" ] } ] } In addition to permission to assume the CDK deployment roles, the following are examples of using AWS managed policies to provide additional permissions that are required for different commands. Note: Additional permissions might be required, depending on the type of application you're deploying and the services it uses. Command Task Recommended AWS Managed Policies deploy Deploying to Amazon ECS AWSCloudFormationFullAccess, AmazonECS_FullAccess, AmazonEC2ContainerRegistryFullAccess, AmazonSSMFullAccess, IAMFullAccess deploy Deploying to AWS App Runner AWSCloudFormationFullAccess, AWSAppRunnerFullAccess, AmazonEC2ContainerRegistryFullAccess, AmazonSSMFullAccess, IAMFullAccess deploy Deploying to AWS Elastic Beanstalk AWSCloudFormationFullAccess, AdministratorAccess-AWSElasticBeanstalk, AmazonSSMFullAccess, AmazonS3FullAccess ( required to upload the application bundle ), IAMFullAccess deploy Hosting WebAssembly Blazor App in Amazon S3 & Amazon CloudFront AmazonS3FullAccess, CloudFrontFullAccess, IAMFullAccess, AmazonSSMFullAccess, AWSLambda_FullAccess ( required to copy from CDKBootstrap bucket to S3 bucket ) list-deployments List AWS CloudFormation stacks AWSCloudFormationReadOnlyAccess delete-deployment Delete an AWS CloudFormation stack AWSCloudFormationFullAccess + permissions for resources being deleted Note: If you are creating IAM roles, you need IAMFullAccess otherwise IAMReadOnlyAccess. Note that the first time the CDK bootstrap stack is created it will need IAMFullAccess. Note: If you encounter an error saying user is not authorized to perform action because no identity based policies allow it , that means you need to add the corresponding permission to the IAM policy that is used by the current IAM role/user. The exact wording for an insufficient permissions related errors may differ. Specifying profile and region In your shared AWS config and credentials files, if the [default] profile exists, the deployment tool uses that profile by default. You can change this behavior by specifying a profile for the tool to use, either system-wide or in a particular context. ... locally The simplest way to specify region and profile is to provide them as parameters to the tool. dotnet aws deploy --profile customProfile --region us-west-2 For additional information about command parameters, see Commands section. Note If you provide only the --profile argument, the AWS Region isn't read from the profile that you specify. Instead, the tool reads the Region from the [default] profile if one exists, or asks for the desired profile interactively. ... system-wide To specify a system-wide profile and region, define the AWS_PROFILE and AWS_REGION environment variables globally, as appropriate for your operating system. Be sure to reopen command prompts or terminals as necessary. Warning If you set the AWS_PROFILE environment variable globally for your system, other SDKs, CLIs, and tools will also use that profile. If this behavior is unacceptable, specify a profile for a particular context instead. Additional Resources For information on AWS credentials and access management, see Credentials and Access For information on configuration file settings, see Config and Auth Settings Reference For information on how to create customer managed IAM policies, see Tutorial on Managed Policies For information on how to troubleshoot IAM policies, see AWS IAM User Guide For information on AWS Single Sign On (AWS SSO), visit the .NET SDK Reference Guide . For information on how to provide AWS credentials in AWS Toolkit for Visual Studio, see AWS Toolkit for Visual Studio User Guide .","title":"Set up credentials"},{"location":"docs/getting-started/setup-creds/#set-up-credentials","text":"The AWS Deploy Tool for .NET internally uses a variety of different tools and services to host your .NET application on AWS. To run the AWS Deploy Tool, you must configure a credential profile that provides access to the AWS account you wish to deploy to. Your credentials must have permissions for certain services, depending on the tasks that you're trying to perform.","title":"Set up credentials"},{"location":"docs/getting-started/setup-creds/#recommended-policies","text":"The AWS Deploy Tool for .NET uses AWS Cloud Development Kit (CDK) to create the AWS infrastructure needed to deploy your application. Deploying via AWS CDK will assume roles that were created when bootstrapping CDK for the account and region you are deploying into. Ensure that the profile you are deploying with has permission to assume the CDK deployment roles. This can be done with a policy such as: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"sts:AssumeRole\" ], \"Resource\": [ \"arn:aws:iam::*:role/cdk-*\" ] } ] } In addition to permission to assume the CDK deployment roles, the following are examples of using AWS managed policies to provide additional permissions that are required for different commands. Note: Additional permissions might be required, depending on the type of application you're deploying and the services it uses. Command Task Recommended AWS Managed Policies deploy Deploying to Amazon ECS AWSCloudFormationFullAccess, AmazonECS_FullAccess, AmazonEC2ContainerRegistryFullAccess, AmazonSSMFullAccess, IAMFullAccess deploy Deploying to AWS App Runner AWSCloudFormationFullAccess, AWSAppRunnerFullAccess, AmazonEC2ContainerRegistryFullAccess, AmazonSSMFullAccess, IAMFullAccess deploy Deploying to AWS Elastic Beanstalk AWSCloudFormationFullAccess, AdministratorAccess-AWSElasticBeanstalk, AmazonSSMFullAccess, AmazonS3FullAccess ( required to upload the application bundle ), IAMFullAccess deploy Hosting WebAssembly Blazor App in Amazon S3 & Amazon CloudFront AmazonS3FullAccess, CloudFrontFullAccess, IAMFullAccess, AmazonSSMFullAccess, AWSLambda_FullAccess ( required to copy from CDKBootstrap bucket to S3 bucket ) list-deployments List AWS CloudFormation stacks AWSCloudFormationReadOnlyAccess delete-deployment Delete an AWS CloudFormation stack AWSCloudFormationFullAccess + permissions for resources being deleted Note: If you are creating IAM roles, you need IAMFullAccess otherwise IAMReadOnlyAccess. Note that the first time the CDK bootstrap stack is created it will need IAMFullAccess. Note: If you encounter an error saying user is not authorized to perform action because no identity based policies allow it , that means you need to add the corresponding permission to the IAM policy that is used by the current IAM role/user. The exact wording for an insufficient permissions related errors may differ.","title":"Recommended policies"},{"location":"docs/getting-started/setup-creds/#specifying-profile-and-region","text":"In your shared AWS config and credentials files, if the [default] profile exists, the deployment tool uses that profile by default. You can change this behavior by specifying a profile for the tool to use, either system-wide or in a particular context.","title":"Specifying profile and region"},{"location":"docs/getting-started/setup-creds/#locally","text":"The simplest way to specify region and profile is to provide them as parameters to the tool. dotnet aws deploy --profile customProfile --region us-west-2 For additional information about command parameters, see Commands section. Note If you provide only the --profile argument, the AWS Region isn't read from the profile that you specify. Instead, the tool reads the Region from the [default] profile if one exists, or asks for the desired profile interactively.","title":"... locally"},{"location":"docs/getting-started/setup-creds/#system-wide","text":"To specify a system-wide profile and region, define the AWS_PROFILE and AWS_REGION environment variables globally, as appropriate for your operating system. Be sure to reopen command prompts or terminals as necessary. Warning If you set the AWS_PROFILE environment variable globally for your system, other SDKs, CLIs, and tools will also use that profile. If this behavior is unacceptable, specify a profile for a particular context instead.","title":"... system-wide"},{"location":"docs/getting-started/setup-creds/#additional-resources","text":"For information on AWS credentials and access management, see Credentials and Access For information on configuration file settings, see Config and Auth Settings Reference For information on how to create customer managed IAM policies, see Tutorial on Managed Policies For information on how to troubleshoot IAM policies, see AWS IAM User Guide For information on AWS Single Sign On (AWS SSO), visit the .NET SDK Reference Guide . For information on how to provide AWS credentials in AWS Toolkit for Visual Studio, see AWS Toolkit for Visual Studio User Guide .","title":"Additional Resources"},{"location":"troubleshooting-guide/","text":"General Issues This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues you might encounter during the deployment process. Invalid project path provided Why is this happening : The CLI deployment command takes in an optional --project-path option. For example: dotnet aws deploy --project-path <PATH> The deployment process would fail if an invalid --project-path is provided. Resolution : The --project-path can be absolute or relative to the current working directory and must be one of the following: A file path pointing to a *.csproj or *.fsproj file. A directory path that contains a *.csproj or *.fsproj file. If a --project-path option is not provided, then AWS.Deploy.Tools will look for a *.csproj or *.fsproj file in the current working directory. Failed to find compatible deployment recommendations Why is this happening : Behind the scenes, AWS.Deploy.Tools uses a recipe configuration file to provide an opinionated deployment experience. See here to learn more about recipes. Recipe configurations target different AWS services and there may be incompatibilities between the chosen recipe and your .NET application. Another reason why there are no recommendations generated is if your application's .csproj file is using a variable for the TargetFramework property. For example: <Project Sdk=\"Microsoft.NET.Sdk.Web\"> <PropertyGroup> <TargetFrameworkVersion>net6.0</TargetFrameworkVersion> <TargetFramework>$(TargetFrameworkVersion)</TargetFramework> </PropertyGroup> </Project> No recommendations will be generated for the above .csproj file. This is a bug which we will address : GitHub issue . Meanwhile, please provide explicit values for the TargetFramework property. Resolution : If you think that your project is not correctly recognized by our tool and no recommendations are generated, then file a GitHub issue describing your project and also providing relevant details about your .csproj or .fsproj file. This will help us understand and narrow down the gaps in our recommendation engine and customer use cases. Deployment failures related to JSON configuration file Why is this happening : AWS.Deploy.Tools allows for prompt-less deployments using a JSON configuration file. This workflow can easily be plugged into your CI/CD pipeline for automated deployments. If a deployment failure occurs while using a configuration file, It is possible that the configuration file has the wrong definition or the wrong format. Resolution : Kindly ensure that the JSON configuration file has the correct JSON syntax. See here for an example of a valid JSON configuration file. Insufficient IAM Permissions Why is this happening : Access to AWS is governed by IAM policies. They are a group of permissions which determine whether the request to an AWS resource/service is allowed or denied. AWS.Deploy.Tools, internally uses a variety of different services to host your .NET application on AWS. If you encounter an error saying user is not authorized to perform action because no identity based policies allow it , that means you need to add the corresponding permission to the IAM policy that is used by the current IAM role/user. Note: Exact wording for an insufficient permissions related errors may differ from the above Resolution : You can refer to the official AWS documentation on IAM policies: See here for a tutorial on how to create customer managed IAM policies. See here for troubleshooting IAM policies. Deployment failure due to whitespace character in USERPROFILE path Why is this happening : This happens due to a know issue with the AWS Cloud Development Kit (CDK). The CDK is used by AWS.Deploy.Tools under the covers and it cannot cannot access the $TEMP directory inside the $USERPROFILE path if it contains a whitespace character. Resolution : See here for guidance on setting a custom workspace that will be used by AWS.Deploy.Tools. AWS CDK Bootstrap related Deployment Failure A common error that is displayed for CDK Bootstrap related deployment failures is the following: The AWS CDK Bootstrap, which is the process of provisioning initial resources for the deployment environment, has failed. Please review the output above for additional details [and check out our troubleshooting guide for the most common failure reasons]. You can learn more about CDK bootstrapping at https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html. The AWS Deploy Tool for .NET uses AWS CDK to create the AWS infrastructure needed to deploy your application. The AWS CDK is a framework for defining cloud infrastructure in code and provisioning it through AWS CloudFormation. Deploying AWS CDK apps into an AWS environment (a combination of an AWS account and region) requires that you provision resources the AWS CDK needs to perform the deployment. These resources include an Amazon S3 bucket for storing files and IAM roles that grant permissions needed to perform deployments. The process of provisioning these initial resources is called bootstrapping . The required resources are defined in a AWS CloudFormation stack, called the bootstrap stack, which is usually named CDKToolkit . Like any AWS CloudFormation stack, it appears in the AWS CloudFormation console once it has been deployed. There could be several reasons why you are experiencing this issue. However, the most common ones are related to Insufficient IAM Permissions and an Existing CDK Staging Bucket . Insufficient IAM Permission : CDKBoostrap failed because your profile does not have sufficient permissions to create the boostrap stack. Check the log - in this case, you should see an error that looks something like this: LookupRole API: iam:GetRole User: arn:aws:iam::123456789101:user/user is not authorized to perform: iam:GetRole on resource Resolution : Add missing IAM permissions to your profile. See our documentation for recommended IAM policies for each deployment type. Existing CDKToolkit S3 bucket : In rare cases, it is possible for the CDK Boostrap process to not clean the resources properly after the failed deployment. This causes the next deployment to fail as well, because the S3 bucket already exists. The error could look something like: StagingBucket cdk-hnb659fds-assets-123456789101-us-west-2 already exists Resolution : Open the AWS Console, go to S3 service, and manually delete the 'CDKToolkit' S3 bucket. Once the bucket is deleted, go ahead and deploy your application. MemorySize Constraint for Blazor WebAssembly When attempting to deploy using the Blazor WebAssembly App recipe, you may see a deployment failure such as: Resource handler returned message: \"'MemorySize' value failed to satisfy constraint: Member must have value less than or equal to 3008 Why this is happening: The BucketDeployment CDK Construct used to deploy the Blazor recipe uses an AWS Lambda function to replicate the application files from the CDK bucket to the deployment bucket. In some versions of the deploy tool the default memory limit for this Lambda function exceeded the 3008MB quota placed on new AWS accounts. Resolution: See Lambda: Concurrency and memory quotas for how to request a quota increase. App Runner Failed with Resource handler returned message: \"null\" When attempting to deploy to App Runner, creation of the AWS::AppRunner::Service resource may fail with a message such as: CREATE_FAILED | AWS::AppRunner::Service | Recipe/AppRunnerService (RecipeAppRunnerService) Resource handler returned message: \"null\" Why this is happening: This error could happen for a variety of reasons, such as the application failing its initial health check or limited permissions. Resolution: The resolution will depend on the failure reason. To aid diagnosis, attempt to deploy your application again. While it is deploying, navigate to the the Deployment and Application logs sections of App Runner > Services > [name of your cloud application] in the AWS Console and review the logs for any unexpected errors. See Viewing App Runner logs streamed to CloudWatch Logs for more details.","title":"General Issues"},{"location":"troubleshooting-guide/#general-issues","text":"This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues you might encounter during the deployment process.","title":"General Issues"},{"location":"troubleshooting-guide/#invalid-project-path-provided","text":"Why is this happening : The CLI deployment command takes in an optional --project-path option. For example: dotnet aws deploy --project-path <PATH> The deployment process would fail if an invalid --project-path is provided. Resolution : The --project-path can be absolute or relative to the current working directory and must be one of the following: A file path pointing to a *.csproj or *.fsproj file. A directory path that contains a *.csproj or *.fsproj file. If a --project-path option is not provided, then AWS.Deploy.Tools will look for a *.csproj or *.fsproj file in the current working directory.","title":"Invalid project path provided"},{"location":"troubleshooting-guide/#failed-to-find-compatible-deployment-recommendations","text":"Why is this happening : Behind the scenes, AWS.Deploy.Tools uses a recipe configuration file to provide an opinionated deployment experience. See here to learn more about recipes. Recipe configurations target different AWS services and there may be incompatibilities between the chosen recipe and your .NET application. Another reason why there are no recommendations generated is if your application's .csproj file is using a variable for the TargetFramework property. For example: <Project Sdk=\"Microsoft.NET.Sdk.Web\"> <PropertyGroup> <TargetFrameworkVersion>net6.0</TargetFrameworkVersion> <TargetFramework>$(TargetFrameworkVersion)</TargetFramework> </PropertyGroup> </Project> No recommendations will be generated for the above .csproj file. This is a bug which we will address : GitHub issue . Meanwhile, please provide explicit values for the TargetFramework property. Resolution : If you think that your project is not correctly recognized by our tool and no recommendations are generated, then file a GitHub issue describing your project and also providing relevant details about your .csproj or .fsproj file. This will help us understand and narrow down the gaps in our recommendation engine and customer use cases.","title":"Failed to find compatible deployment recommendations"},{"location":"troubleshooting-guide/#deployment-failures-related-to-json-configuration-file","text":"Why is this happening : AWS.Deploy.Tools allows for prompt-less deployments using a JSON configuration file. This workflow can easily be plugged into your CI/CD pipeline for automated deployments. If a deployment failure occurs while using a configuration file, It is possible that the configuration file has the wrong definition or the wrong format. Resolution : Kindly ensure that the JSON configuration file has the correct JSON syntax. See here for an example of a valid JSON configuration file.","title":"Deployment failures related to JSON configuration file"},{"location":"troubleshooting-guide/#insufficient-iam-permissions","text":"Why is this happening : Access to AWS is governed by IAM policies. They are a group of permissions which determine whether the request to an AWS resource/service is allowed or denied. AWS.Deploy.Tools, internally uses a variety of different services to host your .NET application on AWS. If you encounter an error saying user is not authorized to perform action because no identity based policies allow it , that means you need to add the corresponding permission to the IAM policy that is used by the current IAM role/user. Note: Exact wording for an insufficient permissions related errors may differ from the above Resolution : You can refer to the official AWS documentation on IAM policies: See here for a tutorial on how to create customer managed IAM policies. See here for troubleshooting IAM policies.","title":"Insufficient IAM Permissions"},{"location":"troubleshooting-guide/#deployment-failure-due-to-whitespace-character-in-userprofile-path","text":"Why is this happening : This happens due to a know issue with the AWS Cloud Development Kit (CDK). The CDK is used by AWS.Deploy.Tools under the covers and it cannot cannot access the $TEMP directory inside the $USERPROFILE path if it contains a whitespace character. Resolution : See here for guidance on setting a custom workspace that will be used by AWS.Deploy.Tools.","title":"Deployment failure due to whitespace character in USERPROFILE path"},{"location":"troubleshooting-guide/#aws-cdk-bootstrap-related-deployment-failure","text":"A common error that is displayed for CDK Bootstrap related deployment failures is the following: The AWS CDK Bootstrap, which is the process of provisioning initial resources for the deployment environment, has failed. Please review the output above for additional details [and check out our troubleshooting guide for the most common failure reasons]. You can learn more about CDK bootstrapping at https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html. The AWS Deploy Tool for .NET uses AWS CDK to create the AWS infrastructure needed to deploy your application. The AWS CDK is a framework for defining cloud infrastructure in code and provisioning it through AWS CloudFormation. Deploying AWS CDK apps into an AWS environment (a combination of an AWS account and region) requires that you provision resources the AWS CDK needs to perform the deployment. These resources include an Amazon S3 bucket for storing files and IAM roles that grant permissions needed to perform deployments. The process of provisioning these initial resources is called bootstrapping . The required resources are defined in a AWS CloudFormation stack, called the bootstrap stack, which is usually named CDKToolkit . Like any AWS CloudFormation stack, it appears in the AWS CloudFormation console once it has been deployed. There could be several reasons why you are experiencing this issue. However, the most common ones are related to Insufficient IAM Permissions and an Existing CDK Staging Bucket . Insufficient IAM Permission : CDKBoostrap failed because your profile does not have sufficient permissions to create the boostrap stack. Check the log - in this case, you should see an error that looks something like this: LookupRole API: iam:GetRole User: arn:aws:iam::123456789101:user/user is not authorized to perform: iam:GetRole on resource Resolution : Add missing IAM permissions to your profile. See our documentation for recommended IAM policies for each deployment type. Existing CDKToolkit S3 bucket : In rare cases, it is possible for the CDK Boostrap process to not clean the resources properly after the failed deployment. This causes the next deployment to fail as well, because the S3 bucket already exists. The error could look something like: StagingBucket cdk-hnb659fds-assets-123456789101-us-west-2 already exists Resolution : Open the AWS Console, go to S3 service, and manually delete the 'CDKToolkit' S3 bucket. Once the bucket is deleted, go ahead and deploy your application.","title":"AWS CDK Bootstrap related Deployment Failure"},{"location":"troubleshooting-guide/#memorysize-constraint-for-blazor-webassembly","text":"When attempting to deploy using the Blazor WebAssembly App recipe, you may see a deployment failure such as: Resource handler returned message: \"'MemorySize' value failed to satisfy constraint: Member must have value less than or equal to 3008 Why this is happening: The BucketDeployment CDK Construct used to deploy the Blazor recipe uses an AWS Lambda function to replicate the application files from the CDK bucket to the deployment bucket. In some versions of the deploy tool the default memory limit for this Lambda function exceeded the 3008MB quota placed on new AWS accounts. Resolution: See Lambda: Concurrency and memory quotas for how to request a quota increase.","title":"MemorySize Constraint for Blazor WebAssembly"},{"location":"troubleshooting-guide/#app-runner-failed-with-resource-handler-returned-message-null","text":"When attempting to deploy to App Runner, creation of the AWS::AppRunner::Service resource may fail with a message such as: CREATE_FAILED | AWS::AppRunner::Service | Recipe/AppRunnerService (RecipeAppRunnerService) Resource handler returned message: \"null\" Why this is happening: This error could happen for a variety of reasons, such as the application failing its initial health check or limited permissions. Resolution: The resolution will depend on the failure reason. To aid diagnosis, attempt to deploy your application again. While it is deploying, navigate to the the Deployment and Application logs sections of App Runner > Services > [name of your cloud application] in the AWS Console and review the logs for any unexpected errors. See Viewing App Runner logs streamed to CloudWatch Logs for more details.","title":"App Runner Failed with Resource handler returned message: \"null\""},{"location":"troubleshooting-guide/docker-issues/","text":"Docker Issues This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues related to Docker. Docker not running in Linux mode Why is this happening : If you are on a Windows operating system, it is likely that you are running Docker in Windows container mode. AWS.Deploy.Tools requires Docker to be running in Linux container mode. Resolution : See here to switch between Windows and Linux containers. Failed to build Docker Image There are multiple reasons your deployment may fail during the Docker build step. Invalid Dockerfile Why is this happening : If there is a syntax error or invalid argument in your Dockerfile, the Docker build command may fail with an error message like this: failed to solve with frontend dockerfile.v0: failed to create LLB definition: <additional error message> Resolution : Correct any syntax errors or invalid arguments in your Dockerfile. Consult Docker's Dockerfile reference for the expected syntax for each instruction. Invalid Docker execution directory Why is this happening : The Docker execution directory is the working directory for the Docker build command . All relative paths in the Dockerfile are resolved from this directory. By default, the execution directory is set to your project's solution directory. However it is possible that the Dockerfile is referencing projects outside of your solution directory, which may result in an error message like this: failed to compute cache key: \"/Path/To/A/Dependency.csproj\" not found: not found Resolution : AWS.Deploy.Tools allows you to specify an alternative Docker execution directory. Try setting an execution directory that can correctly evaluate all relative paths in the Dockerfile. If you are using the CLI version of AWS.Deploy.Tools, set the \"Docker Execution Directory\" under \"Advanced Settings.\" If you are using the \"Publish to AWS\" feature in the AWS Toolkit for Visual Studio, set the \"Docker Execution Directory\" under the \"Project Build\" settings. Missing project dependencies Why is this happening : The Docker build command may fail during the RUN dotnet build instruction if all of your project dependencies are not specified in the Dockerfile. Resolution : Ensure all dependencies from your project and solution files are included in your Dockerfile. A good starting point is to inspect the solution file and add the relevant projects to the Dockerfile. If a custom Dockerfile is not initally provided, AWS.Deploy.Tools will generate one if you select a container-based deployment. The generated Dockerfile will include the projects currently defined in your solution file. This Dockerfile is persisted on disk. If you add a new dependency to the solution file in the future, you must manually add a new entry for it in the persisted Dockerfile. Failed to restore package references Why is this happening : The Docker build command may fail during the RUN dotnet restore instruction if the container does not have connectivity to the NuGet. You may see an error message like: Unable to load the service index for source https://api.nuget.org/v3/index.json or Failed to download package <package name> from https://api.nuget.org/ Resolution : Your container may be unable to access the internet or NuGet for a variety of network-related reasons. If you are using Docker Desktop, consult the Docker troubleshooting guide and documentation . If your container is able to access the internet but the package restore is failing because you are using a private NuGet feed, you may need to configure credentials for the private feed within the Dockerfile. Failed to push Docker Image Why is this happening : AWS.Deploy.Tools builds the Docker image and pushes it to Amazon Elastic Container Registry (Amazon ECR). If you are missing the required AWS Identity and Access Management (IAM) permissions to perform actions against ECR repositories, the deployment may fail the following error message: Failed to push Docker Image Resolution : See here for guidance on how to set IAM policy statements to allow actions on Amazon ECR repositories. Failed to generate a Dockerfile Why is this happening You may see this if your project has project references (.csproj, .vbproj) that are located in a higher folder than the solution file (.sln) that AWS.Deploy.Tools is using to generate a Dockerfile. In this case AWS.Deploy.Tools will not generate a Dockerfile to avoid a large build context that can result in long builds. Resolution : If you would still like to deploy to an AWS service that requires Docker , you must create your own Dockerfile and set an appropriate \"Docker Execution Directory\" in the deployment options. Alternatively you may choose another deployment target that does not require Docker, such as AWS Elastic Beanstalk. Application deployment stuck or fails because of health check Microsoft has made changes to the base images used in .NET 8 which now expose 8080 as the default HTTP port instead of the port 80 which was used in previous versions. In addition to that, Microsoft now uses a non-root user by default. As we added support for deploying .NET 8 container-based applications, the container port setting in the recipes that support it now defaults to 8080 for .NET 8 and 80 in previous versions. For applications that do not have a dockerfile , we generate one accordingly. However, for applications that have their own dockerfile , the user is responsible for setting and exposing the proper port. If the container port is different from the port exposed in the container, the deployment might keep going until it reaches a timeout from the underlying services, or you might receive an error related to the health check. In the tool, we have added a warning message if we detect that the container port setting is different from the one exposed in the container.","title":"Docker Issues"},{"location":"troubleshooting-guide/docker-issues/#docker-issues","text":"This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues related to Docker.","title":"Docker Issues"},{"location":"troubleshooting-guide/docker-issues/#docker-not-running-in-linux-mode","text":"Why is this happening : If you are on a Windows operating system, it is likely that you are running Docker in Windows container mode. AWS.Deploy.Tools requires Docker to be running in Linux container mode. Resolution : See here to switch between Windows and Linux containers.","title":"Docker not running in Linux mode"},{"location":"troubleshooting-guide/docker-issues/#failed-to-build-docker-image","text":"There are multiple reasons your deployment may fail during the Docker build step.","title":"Failed to build Docker Image"},{"location":"troubleshooting-guide/docker-issues/#invalid-dockerfile","text":"Why is this happening : If there is a syntax error or invalid argument in your Dockerfile, the Docker build command may fail with an error message like this: failed to solve with frontend dockerfile.v0: failed to create LLB definition: <additional error message> Resolution : Correct any syntax errors or invalid arguments in your Dockerfile. Consult Docker's Dockerfile reference for the expected syntax for each instruction.","title":"Invalid Dockerfile"},{"location":"troubleshooting-guide/docker-issues/#invalid-docker-execution-directory","text":"Why is this happening : The Docker execution directory is the working directory for the Docker build command . All relative paths in the Dockerfile are resolved from this directory. By default, the execution directory is set to your project's solution directory. However it is possible that the Dockerfile is referencing projects outside of your solution directory, which may result in an error message like this: failed to compute cache key: \"/Path/To/A/Dependency.csproj\" not found: not found Resolution : AWS.Deploy.Tools allows you to specify an alternative Docker execution directory. Try setting an execution directory that can correctly evaluate all relative paths in the Dockerfile. If you are using the CLI version of AWS.Deploy.Tools, set the \"Docker Execution Directory\" under \"Advanced Settings.\" If you are using the \"Publish to AWS\" feature in the AWS Toolkit for Visual Studio, set the \"Docker Execution Directory\" under the \"Project Build\" settings.","title":"Invalid Docker execution directory"},{"location":"troubleshooting-guide/docker-issues/#missing-project-dependencies","text":"Why is this happening : The Docker build command may fail during the RUN dotnet build instruction if all of your project dependencies are not specified in the Dockerfile. Resolution : Ensure all dependencies from your project and solution files are included in your Dockerfile. A good starting point is to inspect the solution file and add the relevant projects to the Dockerfile. If a custom Dockerfile is not initally provided, AWS.Deploy.Tools will generate one if you select a container-based deployment. The generated Dockerfile will include the projects currently defined in your solution file. This Dockerfile is persisted on disk. If you add a new dependency to the solution file in the future, you must manually add a new entry for it in the persisted Dockerfile.","title":"Missing project dependencies"},{"location":"troubleshooting-guide/docker-issues/#failed-to-restore-package-references","text":"Why is this happening : The Docker build command may fail during the RUN dotnet restore instruction if the container does not have connectivity to the NuGet. You may see an error message like: Unable to load the service index for source https://api.nuget.org/v3/index.json or Failed to download package <package name> from https://api.nuget.org/ Resolution : Your container may be unable to access the internet or NuGet for a variety of network-related reasons. If you are using Docker Desktop, consult the Docker troubleshooting guide and documentation . If your container is able to access the internet but the package restore is failing because you are using a private NuGet feed, you may need to configure credentials for the private feed within the Dockerfile.","title":"Failed to restore package references"},{"location":"troubleshooting-guide/docker-issues/#failed-to-push-docker-image","text":"Why is this happening : AWS.Deploy.Tools builds the Docker image and pushes it to Amazon Elastic Container Registry (Amazon ECR). If you are missing the required AWS Identity and Access Management (IAM) permissions to perform actions against ECR repositories, the deployment may fail the following error message: Failed to push Docker Image Resolution : See here for guidance on how to set IAM policy statements to allow actions on Amazon ECR repositories.","title":"Failed to push Docker Image"},{"location":"troubleshooting-guide/docker-issues/#failed-to-generate-a-dockerfile","text":"Why is this happening You may see this if your project has project references (.csproj, .vbproj) that are located in a higher folder than the solution file (.sln) that AWS.Deploy.Tools is using to generate a Dockerfile. In this case AWS.Deploy.Tools will not generate a Dockerfile to avoid a large build context that can result in long builds. Resolution : If you would still like to deploy to an AWS service that requires Docker , you must create your own Dockerfile and set an appropriate \"Docker Execution Directory\" in the deployment options. Alternatively you may choose another deployment target that does not require Docker, such as AWS Elastic Beanstalk.","title":"Failed to generate a Dockerfile"},{"location":"troubleshooting-guide/docker-issues/#application-deployment-stuck-or-fails-because-of-health-check","text":"Microsoft has made changes to the base images used in .NET 8 which now expose 8080 as the default HTTP port instead of the port 80 which was used in previous versions. In addition to that, Microsoft now uses a non-root user by default. As we added support for deploying .NET 8 container-based applications, the container port setting in the recipes that support it now defaults to 8080 for .NET 8 and 80 in previous versions. For applications that do not have a dockerfile , we generate one accordingly. However, for applications that have their own dockerfile , the user is responsible for setting and exposing the proper port. If the container port is different from the port exposed in the container, the deployment might keep going until it reaches a timeout from the underlying services, or you might receive an error related to the health check. In the tool, we have added a warning message if we detect that the container port setting is different from the one exposed in the container.","title":"Application deployment stuck or fails because of health check"},{"location":"troubleshooting-guide/missing-dependencies/","text":"Missing Dependencies This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues related to missing external dependencies of AWS.Deploy.Tools Node.js not installed Why is this happening : AWS.Deploy.Tools relies on AWS Cloud Development Kit (CDK) to provision resources for your cloud application. AWS CDK requires Node.js to be installed in your machine. See the CDK's FAQs for more information about how it uses Node.js. Minimum required Node.js version >= 14.17.0 Resolution : See here to install Node.js on your system. Docker not installed Why is this happening : AWS.Deploy.Tool requires Docker to be installed in order to perform containerized deployments. Resolution : See here to install Docker for your operating system. Zip utility not installed Why is this happening : Non-container based deployments types (such as deployments to AWS Elastic Beanstalk) create a zip file of the artifacts produced by the dotnet publish command. The zip command line utility is not installed by default on some Linux distributions. If you are deploying using a non-container based option, you may encounter an error saying: We were unable to create a zip archive of the packaged application. Normally this indicates a problem running the \\\"zip\\\" utility. Make sure that application is installed and available in your PATH. In this case, it is likely that zip is not installed on your system. We use the Linux zip tool to maintain Linux file permissions. Resolution : To install zip on Linux OS, run the following commands depending on your distribution's package management tool. For distributions using apt-get : sudo apt-get install zip For distributions using yum : sudo yum intall zip After installation, use the command to verify that zip was installed correctly. zip","title":"Missing Dependencies"},{"location":"troubleshooting-guide/missing-dependencies/#missing-dependencies","text":"This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues related to missing external dependencies of AWS.Deploy.Tools","title":"Missing Dependencies"},{"location":"troubleshooting-guide/missing-dependencies/#nodejs-not-installed","text":"Why is this happening : AWS.Deploy.Tools relies on AWS Cloud Development Kit (CDK) to provision resources for your cloud application. AWS CDK requires Node.js to be installed in your machine. See the CDK's FAQs for more information about how it uses Node.js. Minimum required Node.js version >= 14.17.0 Resolution : See here to install Node.js on your system.","title":"Node.js not installed"},{"location":"troubleshooting-guide/missing-dependencies/#docker-not-installed","text":"Why is this happening : AWS.Deploy.Tool requires Docker to be installed in order to perform containerized deployments. Resolution : See here to install Docker for your operating system.","title":"Docker not installed"},{"location":"troubleshooting-guide/missing-dependencies/#zip-utility-not-installed","text":"Why is this happening : Non-container based deployments types (such as deployments to AWS Elastic Beanstalk) create a zip file of the artifacts produced by the dotnet publish command. The zip command line utility is not installed by default on some Linux distributions. If you are deploying using a non-container based option, you may encounter an error saying: We were unable to create a zip archive of the packaged application. Normally this indicates a problem running the \\\"zip\\\" utility. Make sure that application is installed and available in your PATH. In this case, it is likely that zip is not installed on your system. We use the Linux zip tool to maintain Linux file permissions. Resolution : To install zip on Linux OS, run the following commands depending on your distribution's package management tool. For distributions using apt-get : sudo apt-get install zip For distributions using yum : sudo yum intall zip After installation, use the command to verify that zip was installed correctly. zip","title":"Zip utility not installed"},{"location":"tutorials/custom-project/","text":"Adding an Amazon DynamoDB table to your deployment project In this tutorial, we will create and customize a deployment project to deploy a web application that uses an Amazon DynamoDB table as the backend store to Amazon Elastic Container Service (ECS). We will then add the deployment project to the source control and share with the team for future deployments. Tasks we will accomplish: Create a new web application called Acme.WebApp. Generate a deployment project using a built-in recipe. Customize the deployment project's recipe file to allow the user to configure a DynamoDB table. Modify the CDK project to add the new DynamoDB setting options. Modify the CDK project to create the DynamoDB table. Pass the DynamoDB table name to the application code using an environment variable our application reads to know which table to use. Add the deployment project to source control. Deploy our Acme.WebApp application using the custom deployment project. Note: This tutorial is not concerned with the application logic. You can replace the sample Acme.WebApp used in this tutorial with any other web application.*** Step 1: Create a new web application In your command prompt, run the following command to create your app: dotnet new webapp -o Acme.WebApp -f net6.0 Step 2: Generate a deployment project Navigate to the Acme.WebApp project directory and run the following command to generate a deployment project: dotnet aws deployment-project generate --output ../Acme.WebApp.DeploymentProject --project-display-name \"ASP.NET Core app with DynamoDB\" The --project-display-name switch above configures the name of the recommendation that is shown in the deploy tool when deploying the application project. The AWS Deploy Tool will analyze the Acme.WebApp project and display which built-in recipes can be used as the starting point of the custom deployment project. Recommended Deployment Option ----------------------------- 1: ASP.NET Core App to AWS Elastic Beanstalk on Linux This ASP.NET Core application will be built and deployed to AWS Elastic Beanstalk on Linux. Recommended if you do not want to deploy your application as a container image. Additional Deployment Options ------------------------------ 2: ASP.NET Core App to Amazon ECS using Fargate This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated. Recommended if you want to deploy your application as a container image on Linux. 3: ASP.NET Core App to AWS App Runner This ASP.NET Core application will be built as a container image and deployed to AWS App Runner. If your project does not contain a Dockerfile, it will be automatically generated. Recommended if you want to deploy your application as a container image on a fully managed environment. 4: ASP.NET Core App to Existing AWS Elastic Beanstalk Environment This ASP.NET Core application will be built and deployed to existing AWS Elastic Beanstalk environment. Recommended if you do not want to deploy your application as a container image. Choose deployment option (recommended default: 1) Pick option #2, \"ASP.NET Core App to Amazon ECS using AWS Fargate\". Acme.WebApp.DeploymentProject is created in a sibling directory to the application project. If you are using Visual Studio, add the new Acme.WebApp.DeploymentProject project to your solution. Step 3: Add DynamoDB settings to the recipe file To give the team members, who will use our deployment project, the choice to either select an existing DynamoDB table or create a new table during deployment, we will add several new settings to our deployment project's recipe definition. Open the Acme.WebApp.DeploymentProject.recipe file located in the deployment project directory in your JSON editor of choice. Go to the OptionSettings section that contains the settings users can use to configure their project. Create a new \"Object\" option setting called Backend to group all of our new settings using the snippet below. When users configure their deployment, this option will be displayed in the \"General\" category. \"OptionSettings\": [ ... { \"Id\": \"Backend\", \"Name\": \"Backend\", \"Category\": \"General\", \"Description\": \"Configure the backend store.\", \"Type\": \"Object\", \"AdvancedSetting\": false, \"Updatable\": true, \"ChildOptionSettings\": [ ] }, ... ] Now we will create child option settings to configure DynamoDB settings. The first is a setting to determine if we should create a new table or not. This setting is a Bool type which is defaulted to true . As a best practice the Updatable setting is set to false to protect users from accidentally deleting the table when redeploying in the future. Add the following snippet to the ChildOptionSettings of the new Backend option we just created: \"ChildOptionSettings\": [ { \"Id\": \"CreateNewTable\", \"Name\": \"Create New DynamoDB Table\", \"Description\": \"Do you want to create a new DynamoDB table for the backend store?\", \"Type\": \"Bool\", \"DefaultValue\": true, \"AdvancedSetting\": false, \"Updatable\": false }, ... ] If the user unchecks the CreateNewTable setting, we need to give them the choice to select an existing table. This ExistingTableName setting is a \"String\" type that will store the name of an existing DynamoDB table to use as the backend store. Add the following snippet to the ChildOptionSettings of the new Backend option: \"ChildOptionSettings\": [ ... { \"Id\": \"ExistingTableName\", \"Name\": \"Existing DynamoDB Table\", \"Description\": \"Existing DynamoDB table to use as the backend store.\", \"Type\": \"String\", \"TypeHint\": \"DynamoDBTableName\", \"DefaultValue\": \"\", \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"Backend.CreateNewTable\", \"Value\": false } ], \"Validators\": [ { \"ValidatorType\": \"Regex\", \"Configuration\": { \"Regex\": \"[a-zA-Z0-9_.-]+\", \"ValidationFailedMessage\": \"Invalid table name.\" } }, { \"ValidatorType\": \"StringLength\", \"Configuration\": { \"MinLength\": 3, \"MaxLength\": 255 } } ] } ] Let us take a deeper dive into the properties for the ExistingTableName setting. TypeHint - Set to DynamoDBTableName which tells the deployment tool this String type contains the name of a DynamoDB table. The deploy tool uses this information to show users a list of tables to pick from instead of a text-box. Updatable - Since modifying the name of an existing table is not a destructive change, we will allow this field to be updated during redeployments. DependsOn - This setting will only be visible if the previous CreateNewTable setting is set to false . Notice how the Id is the full name of the setting including the parent \"Object\" setting Backend . Validators - This attaches validators to make sure that the user-provided name matches the regex for valid table names and that the name meets the required minimum and maximum lengths. Adding validators provides feedback to users when invalid values are provided in either the CLI or Visual Studio. Here is the full snippet of the Backend Object option setting with the child settings: { \"Id\": \"Backend\", \"Name\": \"Backend\", \"Category\": \"General\", \"Description\": \"Configure the backend store.\", \"Type\": \"Object\", \"AdvancedSetting\": false, \"Updatable\": true, \"ChildOptionSettings\": [ { \"Id\": \"CreateNewTable\", \"Name\": \"Create New DynamoDB Table\", \"Description\": \"Do you want to create a new DynamoDB table for the backend store?\", \"Type\": \"Bool\", \"DefaultValue\": true, \"AdvancedSetting\": false, \"Updatable\": false }, { \"Id\": \"ExistingTableName\", \"Name\": \"Existing DynamoDB Table\", \"Description\": \"Existing DynamoDB table to use as the backend store.\", \"Type\": \"String\", \"TypeHint\": \"DynamoDBTableName\", \"DefaultValue\": \"\", \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"Backend.CreateNewTable\", \"Value\": false } ], \"Validators\": [ { \"ValidatorType\": \"Regex\", \"Configuration\": { \"Regex\": \"[a-zA-Z0-9_.-]+\", \"ValidationFailedMessage\": \"Invalid table name.\" } }, { \"ValidatorType\": \"StringLength\", \"Configuration\": { \"MinLength\": 3, \"MaxLength\": 255 } } ] } ] } Step 4. Add new setting options to the CDK project When the CDK project is executed, all settings collected from the user are passed and deserialized into the Configuration type. Now we need to customize the CDK project to store the new setting options by modifying the Configuration type. Create a new class called BackendConfiguration in the Configurations directory. Below is the code for this new type with the properties for CreateNewTable and ExistingTableName . Note: The .NET CDK projects generated by the AWS Deploy Tool have the C# feature Nullable enabled in the project file by default. If you do not want this feature enabled, edit the .csproj file and remove the Nullable project from the PropertyGroup.*** namespace Acme.WebApp.DeploymentProject.Configurations { public class BackendConfiguration { public bool CreateNewTable { get; set; } public string ExistingTableName { get; set; } /// A parameterless constructor is needed for <see cref=\"Microsoft.Extensions.Configuration.ConfigurationBuilder\"/> /// or the classes will fail to initialize. /// The warnings are disabled since a parameterless constructor will allow non-nullable properties to be initialized with null values. #nullable disable warnings public BackendConfiguration() { } #nullable restore warnings public BackendConfiguration( bool createNewTable, string existingTableName) { CreateNewTable = createNewTable; ExistingTableName = existingTableName; } } } In the Configuration.cs file, add a new property for our new backend settings. namespace Acme.WebApp.DeploymentProject.Configurations { public partial class Configuration { public BackendConfiguration Backend { get; set; } = new BackendConfiguration(); } } Notice that the Backend property was added to the partial class that is not in the Generated directory. In both the Configuration and BackendConfiguration types, the property names match the setting ids used in the recipe file. This is important for the data to be property deserialized. Step 5. Add DynamoDB table to the CDK project Note: The AppStack class is the recommended place to customize the AWS resources. Modify the constructor of the AppStack class to check if CreateNewTable is set to true . Then use the Amazon.CDK.AWS.DynamoDB CDK construct to create a table as part of the CloudFormation stack. using Amazon.CDK.AWS.DynamoDB; namespace Acme.WebApp.DeploymentProject { public class AppStack : Stack { private readonly Configuration _configuration; private Table? _ddbBackend; internal AppStack(Construct scope, IDeployToolStackProps<Configuration> props) : base(scope, props.StackName, props) { _configuration = props.RecipeProps.Settings; // Setup callback for generated construct to provide access to customize CDK properties before creating constructs. CDKRecipeCustomizer<Recipe>.CustomizeCDKProps += CustomizeCDKProps; if(_configuration.Backend.CreateNewTable == true) { var backendProps = new TableProps { RemovalPolicy = RemovalPolicy.DESTROY, PartitionKey = new Amazon.CDK.AWS.DynamoDB.Attribute { Name = \"Id\", Type = AttributeType.STRING }, BillingMode = BillingMode.PAY_PER_REQUEST, }; _ddbBackend = new Table(this, \"Backend\", backendProps); } var generatedRecipe = new Recipe(this, props.RecipeProps); } Notice that in the snippet above the table is created before the Recipe construct. The Recipe construct has all the AWS resources that are part of the original built-in ECS recipe that the deployment project was created from. Step 6: Pass the DynamoDB table name to the application code Now that we have our DynamoDB table, we need to pass the table name into our application code. We will do it by setting an environment variable that the application code will read in the CustomizeCDKProps method of the AppStack class. CustomizeCDKProps is a callback method that gets called for each AWS resource about to be created from the Recipe construct. To know which AWS resource is about to be created, compare the evnt.ResourceLogicalName property to the public property name on the Recipe construct. The built-in recipes are written to make sure the resource logical name is the same as the public property name. In our scenario we are looking to see if the AppContainerDefinition is about to be created. When we determine that the callback is for AppContainerDefinition then we cast the evnt.Props to the corresponding property object for AppContainerDefinition , in this case ContainerDefinitionOptions . From ContainerDefinitionOptions we can set the table name in an environment variable. private void CustomizeCDKProps(CustomizePropsEventArgs<Recipe> evnt) { // Example of how to customize the container image definition to include environment variables to the running applications. // if (string.Equals(evnt.ResourceLogicalName, nameof(evnt.Construct.AppContainerDefinition))) { if (evnt.Props is ContainerDefinitionOptions props) { if (props.Environment == null) props.Environment = new Dictionary<string, string>(); if(_ddbBackend != null) { props.Environment[\"BACKEND_TABLE\"] = _ddbBackend.TableName; } else { props.Environment[\"BACKEND_TABLE\"] = _configuration.Backend.ExistingTableName; } } } } Step 6: Add deployment project to source control Check your customized deployment project into your source control repository. This is required to re-deploy your application to existing CloudFormation stacks that were created using custom deployment projects. Step 7: Deploy Acme.WebApp application In your command prompt, run the following command to deploy your application: dotnet aws deploy --project-path . The custom deployment project will be displayed as the recommended option. Recommended Deployment Option ----------------------------- 1: ASP.NET Core app with DynamoDB This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your application as a container image on Linux. Additional Deployment Options ------------------------------ 2: ASP.NET Core App to Amazon ECS using AWS Fargate This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your application as a container image on Linux. ... Select deployment option #1. You can now see Backend settings option we customized. When you navigate to the Backend settings, you will be able to choose between using a new table or picking an existing table. ... Current settings (select number to change its value) ---------------------------------------------------- 1. ECS Cluster: AcmeWebApp 2. ECS Service Name: AcmeWebApp-service 3. Backend: Create New DynamoDB Table: True 4. Desired Task Count: 3 5. Application IAM Role: *** Create new *** 6. Virtual Private Cloud (VPC): *** Default *** 7. Environment Variables: 8. ECR Repository Name: acmewebapp ... Note: The AWS Toolkit for Visual Studio will also recognize the custom deployment project. The deployment project will show up as the highest recommended option and the user will also be able to choose between creating a new table or choosing from a drop-down list of available tables in the account that is being deployed to.","title":"Adding an Amazon DynamoDB table to your deployment project"},{"location":"tutorials/custom-project/#adding-an-amazon-dynamodb-table-to-your-deployment-project","text":"In this tutorial, we will create and customize a deployment project to deploy a web application that uses an Amazon DynamoDB table as the backend store to Amazon Elastic Container Service (ECS). We will then add the deployment project to the source control and share with the team for future deployments. Tasks we will accomplish: Create a new web application called Acme.WebApp. Generate a deployment project using a built-in recipe. Customize the deployment project's recipe file to allow the user to configure a DynamoDB table. Modify the CDK project to add the new DynamoDB setting options. Modify the CDK project to create the DynamoDB table. Pass the DynamoDB table name to the application code using an environment variable our application reads to know which table to use. Add the deployment project to source control. Deploy our Acme.WebApp application using the custom deployment project. Note: This tutorial is not concerned with the application logic. You can replace the sample Acme.WebApp used in this tutorial with any other web application.***","title":"Adding an Amazon DynamoDB table to your deployment project"},{"location":"tutorials/custom-project/#step-1-create-a-new-web-application","text":"In your command prompt, run the following command to create your app: dotnet new webapp -o Acme.WebApp -f net6.0","title":"Step 1: Create a new web application"},{"location":"tutorials/custom-project/#step-2-generate-a-deployment-project","text":"Navigate to the Acme.WebApp project directory and run the following command to generate a deployment project: dotnet aws deployment-project generate --output ../Acme.WebApp.DeploymentProject --project-display-name \"ASP.NET Core app with DynamoDB\" The --project-display-name switch above configures the name of the recommendation that is shown in the deploy tool when deploying the application project. The AWS Deploy Tool will analyze the Acme.WebApp project and display which built-in recipes can be used as the starting point of the custom deployment project. Recommended Deployment Option ----------------------------- 1: ASP.NET Core App to AWS Elastic Beanstalk on Linux This ASP.NET Core application will be built and deployed to AWS Elastic Beanstalk on Linux. Recommended if you do not want to deploy your application as a container image. Additional Deployment Options ------------------------------ 2: ASP.NET Core App to Amazon ECS using Fargate This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated. Recommended if you want to deploy your application as a container image on Linux. 3: ASP.NET Core App to AWS App Runner This ASP.NET Core application will be built as a container image and deployed to AWS App Runner. If your project does not contain a Dockerfile, it will be automatically generated. Recommended if you want to deploy your application as a container image on a fully managed environment. 4: ASP.NET Core App to Existing AWS Elastic Beanstalk Environment This ASP.NET Core application will be built and deployed to existing AWS Elastic Beanstalk environment. Recommended if you do not want to deploy your application as a container image. Choose deployment option (recommended default: 1) Pick option #2, \"ASP.NET Core App to Amazon ECS using AWS Fargate\". Acme.WebApp.DeploymentProject is created in a sibling directory to the application project. If you are using Visual Studio, add the new Acme.WebApp.DeploymentProject project to your solution.","title":"Step 2: Generate a deployment project"},{"location":"tutorials/custom-project/#step-3-add-dynamodb-settings-to-the-recipe-file","text":"To give the team members, who will use our deployment project, the choice to either select an existing DynamoDB table or create a new table during deployment, we will add several new settings to our deployment project's recipe definition. Open the Acme.WebApp.DeploymentProject.recipe file located in the deployment project directory in your JSON editor of choice. Go to the OptionSettings section that contains the settings users can use to configure their project. Create a new \"Object\" option setting called Backend to group all of our new settings using the snippet below. When users configure their deployment, this option will be displayed in the \"General\" category. \"OptionSettings\": [ ... { \"Id\": \"Backend\", \"Name\": \"Backend\", \"Category\": \"General\", \"Description\": \"Configure the backend store.\", \"Type\": \"Object\", \"AdvancedSetting\": false, \"Updatable\": true, \"ChildOptionSettings\": [ ] }, ... ] Now we will create child option settings to configure DynamoDB settings. The first is a setting to determine if we should create a new table or not. This setting is a Bool type which is defaulted to true . As a best practice the Updatable setting is set to false to protect users from accidentally deleting the table when redeploying in the future. Add the following snippet to the ChildOptionSettings of the new Backend option we just created: \"ChildOptionSettings\": [ { \"Id\": \"CreateNewTable\", \"Name\": \"Create New DynamoDB Table\", \"Description\": \"Do you want to create a new DynamoDB table for the backend store?\", \"Type\": \"Bool\", \"DefaultValue\": true, \"AdvancedSetting\": false, \"Updatable\": false }, ... ] If the user unchecks the CreateNewTable setting, we need to give them the choice to select an existing table. This ExistingTableName setting is a \"String\" type that will store the name of an existing DynamoDB table to use as the backend store. Add the following snippet to the ChildOptionSettings of the new Backend option: \"ChildOptionSettings\": [ ... { \"Id\": \"ExistingTableName\", \"Name\": \"Existing DynamoDB Table\", \"Description\": \"Existing DynamoDB table to use as the backend store.\", \"Type\": \"String\", \"TypeHint\": \"DynamoDBTableName\", \"DefaultValue\": \"\", \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"Backend.CreateNewTable\", \"Value\": false } ], \"Validators\": [ { \"ValidatorType\": \"Regex\", \"Configuration\": { \"Regex\": \"[a-zA-Z0-9_.-]+\", \"ValidationFailedMessage\": \"Invalid table name.\" } }, { \"ValidatorType\": \"StringLength\", \"Configuration\": { \"MinLength\": 3, \"MaxLength\": 255 } } ] } ] Let us take a deeper dive into the properties for the ExistingTableName setting. TypeHint - Set to DynamoDBTableName which tells the deployment tool this String type contains the name of a DynamoDB table. The deploy tool uses this information to show users a list of tables to pick from instead of a text-box. Updatable - Since modifying the name of an existing table is not a destructive change, we will allow this field to be updated during redeployments. DependsOn - This setting will only be visible if the previous CreateNewTable setting is set to false . Notice how the Id is the full name of the setting including the parent \"Object\" setting Backend . Validators - This attaches validators to make sure that the user-provided name matches the regex for valid table names and that the name meets the required minimum and maximum lengths. Adding validators provides feedback to users when invalid values are provided in either the CLI or Visual Studio. Here is the full snippet of the Backend Object option setting with the child settings: { \"Id\": \"Backend\", \"Name\": \"Backend\", \"Category\": \"General\", \"Description\": \"Configure the backend store.\", \"Type\": \"Object\", \"AdvancedSetting\": false, \"Updatable\": true, \"ChildOptionSettings\": [ { \"Id\": \"CreateNewTable\", \"Name\": \"Create New DynamoDB Table\", \"Description\": \"Do you want to create a new DynamoDB table for the backend store?\", \"Type\": \"Bool\", \"DefaultValue\": true, \"AdvancedSetting\": false, \"Updatable\": false }, { \"Id\": \"ExistingTableName\", \"Name\": \"Existing DynamoDB Table\", \"Description\": \"Existing DynamoDB table to use as the backend store.\", \"Type\": \"String\", \"TypeHint\": \"DynamoDBTableName\", \"DefaultValue\": \"\", \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"Backend.CreateNewTable\", \"Value\": false } ], \"Validators\": [ { \"ValidatorType\": \"Regex\", \"Configuration\": { \"Regex\": \"[a-zA-Z0-9_.-]+\", \"ValidationFailedMessage\": \"Invalid table name.\" } }, { \"ValidatorType\": \"StringLength\", \"Configuration\": { \"MinLength\": 3, \"MaxLength\": 255 } } ] } ] }","title":"Step 3: Add DynamoDB settings to the recipe file"},{"location":"tutorials/custom-project/#step-4-add-new-setting-options-to-the-cdk-project","text":"When the CDK project is executed, all settings collected from the user are passed and deserialized into the Configuration type. Now we need to customize the CDK project to store the new setting options by modifying the Configuration type. Create a new class called BackendConfiguration in the Configurations directory. Below is the code for this new type with the properties for CreateNewTable and ExistingTableName . Note: The .NET CDK projects generated by the AWS Deploy Tool have the C# feature Nullable enabled in the project file by default. If you do not want this feature enabled, edit the .csproj file and remove the Nullable project from the PropertyGroup.*** namespace Acme.WebApp.DeploymentProject.Configurations { public class BackendConfiguration { public bool CreateNewTable { get; set; } public string ExistingTableName { get; set; } /// A parameterless constructor is needed for <see cref=\"Microsoft.Extensions.Configuration.ConfigurationBuilder\"/> /// or the classes will fail to initialize. /// The warnings are disabled since a parameterless constructor will allow non-nullable properties to be initialized with null values. #nullable disable warnings public BackendConfiguration() { } #nullable restore warnings public BackendConfiguration( bool createNewTable, string existingTableName) { CreateNewTable = createNewTable; ExistingTableName = existingTableName; } } } In the Configuration.cs file, add a new property for our new backend settings. namespace Acme.WebApp.DeploymentProject.Configurations { public partial class Configuration { public BackendConfiguration Backend { get; set; } = new BackendConfiguration(); } } Notice that the Backend property was added to the partial class that is not in the Generated directory. In both the Configuration and BackendConfiguration types, the property names match the setting ids used in the recipe file. This is important for the data to be property deserialized.","title":"Step 4. Add new setting options to the CDK project"},{"location":"tutorials/custom-project/#step-5-add-dynamodb-table-to-the-cdk-project","text":"Note: The AppStack class is the recommended place to customize the AWS resources. Modify the constructor of the AppStack class to check if CreateNewTable is set to true . Then use the Amazon.CDK.AWS.DynamoDB CDK construct to create a table as part of the CloudFormation stack. using Amazon.CDK.AWS.DynamoDB; namespace Acme.WebApp.DeploymentProject { public class AppStack : Stack { private readonly Configuration _configuration; private Table? _ddbBackend; internal AppStack(Construct scope, IDeployToolStackProps<Configuration> props) : base(scope, props.StackName, props) { _configuration = props.RecipeProps.Settings; // Setup callback for generated construct to provide access to customize CDK properties before creating constructs. CDKRecipeCustomizer<Recipe>.CustomizeCDKProps += CustomizeCDKProps; if(_configuration.Backend.CreateNewTable == true) { var backendProps = new TableProps { RemovalPolicy = RemovalPolicy.DESTROY, PartitionKey = new Amazon.CDK.AWS.DynamoDB.Attribute { Name = \"Id\", Type = AttributeType.STRING }, BillingMode = BillingMode.PAY_PER_REQUEST, }; _ddbBackend = new Table(this, \"Backend\", backendProps); } var generatedRecipe = new Recipe(this, props.RecipeProps); } Notice that in the snippet above the table is created before the Recipe construct. The Recipe construct has all the AWS resources that are part of the original built-in ECS recipe that the deployment project was created from.","title":"Step 5. Add DynamoDB table to the CDK project"},{"location":"tutorials/custom-project/#step-6-pass-the-dynamodb-table-name-to-the-application-code","text":"Now that we have our DynamoDB table, we need to pass the table name into our application code. We will do it by setting an environment variable that the application code will read in the CustomizeCDKProps method of the AppStack class. CustomizeCDKProps is a callback method that gets called for each AWS resource about to be created from the Recipe construct. To know which AWS resource is about to be created, compare the evnt.ResourceLogicalName property to the public property name on the Recipe construct. The built-in recipes are written to make sure the resource logical name is the same as the public property name. In our scenario we are looking to see if the AppContainerDefinition is about to be created. When we determine that the callback is for AppContainerDefinition then we cast the evnt.Props to the corresponding property object for AppContainerDefinition , in this case ContainerDefinitionOptions . From ContainerDefinitionOptions we can set the table name in an environment variable. private void CustomizeCDKProps(CustomizePropsEventArgs<Recipe> evnt) { // Example of how to customize the container image definition to include environment variables to the running applications. // if (string.Equals(evnt.ResourceLogicalName, nameof(evnt.Construct.AppContainerDefinition))) { if (evnt.Props is ContainerDefinitionOptions props) { if (props.Environment == null) props.Environment = new Dictionary<string, string>(); if(_ddbBackend != null) { props.Environment[\"BACKEND_TABLE\"] = _ddbBackend.TableName; } else { props.Environment[\"BACKEND_TABLE\"] = _configuration.Backend.ExistingTableName; } } } }","title":"Step 6: Pass the DynamoDB table name to the application code"},{"location":"tutorials/custom-project/#step-6-add-deployment-project-to-source-control","text":"Check your customized deployment project into your source control repository. This is required to re-deploy your application to existing CloudFormation stacks that were created using custom deployment projects.","title":"Step 6: Add deployment project to source control"},{"location":"tutorials/custom-project/#step-7-deploy-acmewebapp-application","text":"In your command prompt, run the following command to deploy your application: dotnet aws deploy --project-path . The custom deployment project will be displayed as the recommended option. Recommended Deployment Option ----------------------------- 1: ASP.NET Core app with DynamoDB This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your application as a container image on Linux. Additional Deployment Options ------------------------------ 2: ASP.NET Core App to Amazon ECS using AWS Fargate This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your application as a container image on Linux. ... Select deployment option #1. You can now see Backend settings option we customized. When you navigate to the Backend settings, you will be able to choose between using a new table or picking an existing table. ... Current settings (select number to change its value) ---------------------------------------------------- 1. ECS Cluster: AcmeWebApp 2. ECS Service Name: AcmeWebApp-service 3. Backend: Create New DynamoDB Table: True 4. Desired Task Count: 3 5. Application IAM Role: *** Create new *** 6. Virtual Private Cloud (VPC): *** Default *** 7. Environment Variables: 8. ECR Repository Name: acmewebapp ... Note: The AWS Toolkit for Visual Studio will also recognize the custom deployment project. The deployment project will show up as the highest recommended option and the user will also be able to choose between creating a new table or choosing from a drop-down list of available tables in the account that is being deployed to.","title":"Step 7: Deploy Acme.WebApp application"}]}